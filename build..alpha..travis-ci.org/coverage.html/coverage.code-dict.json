{"/home/travis/build/npmtest/node-npmtest-webdriver-manager/test.js":"/* istanbul instrument in package npmtest_webdriver_manager */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-webdriver-manager/lib.npmtest_webdriver_manager.js":"/* istanbul instrument in package npmtest_webdriver_manager */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_webdriver_manager = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_webdriver_manager = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-webdriver-manager/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-webdriver-manager && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_webdriver_manager */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_webdriver_manager\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_webdriver_manager.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_webdriver_manager.rollup.js'] =\n            local.assetsDict['/assets.npmtest_webdriver_manager.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_webdriver_manager.__dirname + '/lib.npmtest_webdriver_manager.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/webdriver.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst minimist = require(\"minimist\");\nconst cli_instance_1 = require(\"./cli_instance\");\nlet minimistOptions = cli_instance_1.cli.getMinimistOptions();\nlet argv = minimist(process.argv.slice(2), minimistOptions);\nlet cmd = argv._;\nif (cli_instance_1.cli.programs[cmd[0]]) {\n    if (cmd[0] === 'help') {\n        cli_instance_1.cli.printHelp();\n    }\n    else if (cmd[1] === 'help' || argv['help'] || argv['h']) {\n        cli_instance_1.cli.programs[cmd[0]].printHelp();\n    }\n    else {\n        cli_instance_1.cli.programs[cmd[0]].run(JSON.parse(JSON.stringify(argv)));\n    }\n}\nelse {\n    cli_instance_1.cli.printHelp();\n}\n//# sourceMappingURL=webdriver.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/cli_instance.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cli_1 = require(\"./cli\");\nconst clean = require(\"./cmds/clean\");\nconst shutdown = require(\"./cmds/shutdown\");\nconst start = require(\"./cmds/start\");\nconst status = require(\"./cmds/status\");\nconst update = require(\"./cmds/update\");\nconst version = require(\"./cmds/version\");\nexports.cli = new cli_1.Cli()\n    .usage('webdriver-manager <command> [options]')\n    .program(clean.program)\n    .program(start.program)\n    .program(shutdown.program)\n    .program(status.program)\n    .program(update.program)\n    .program(version.program);\n//# sourceMappingURL=cli_instance.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/cli/index.js":"\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./cli\"));\n__export(require(\"./options\"));\n__export(require(\"./programs\"));\n__export(require(\"./logger\"));\n//# sourceMappingURL=index.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/cli/cli.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The Cli contains the usage and the collection of programs.\n *\n * Printing help for all the programs in the following order:\n * usage, commands, and options. If the options are used in multiple programs,\n * it will list it once.\n */\nclass Cli {\n    constructor() {\n        this.programs = {};\n    }\n    /**\n     * Register a program to the command line interface.\n     * @returns The cli for method chaining.\n     */\n    program(prog) {\n        this.programs[prog.cmd] = prog;\n        return this;\n    }\n    /**\n     * Add a usage for the command line interface.\n     * @returns The cli for method chaining.\n     */\n    usage(usageText) {\n        this.usageText = usageText;\n        return this;\n    }\n    /**\n     * Prints help for the programs registered to the cli.\n     */\n    printHelp() {\n        console.log('Usage: ' + this.usageText);\n        console.log('\\nCommands:');\n        let cmdDescriptionPos = this.posCmdDescription();\n        for (let cmd in this.programs) {\n            let prog = this.programs[cmd];\n            prog.printCmd(cmdDescriptionPos);\n        }\n        let descriptionPos = this.posDescription();\n        let defaultPos = this.posDefault();\n        let extOptions = {};\n        console.log('\\nOptions:');\n        // print all options\n        for (let cmd in this.programs) {\n            let prog = this.programs[cmd];\n            prog.printOptions(descriptionPos, defaultPos, extOptions);\n        }\n    }\n    /**\n     * For commands, gets the position where the description should start so they\n     * are aligned.\n     * @returns The position where the command description should start.\n     */\n    posCmdDescription() {\n        let position = -1;\n        for (let cmd in this.programs) {\n            position = Math.max(position, cmd.length + 6);\n        }\n        return position;\n    }\n    /**\n     * For options, gets the position where the description should start so they\n     * are aligned.\n     * @returns The position where the option description should start.\n     */\n    posDescription() {\n        let position = -1;\n        for (let cmd in this.programs) {\n            let prog = this.programs[cmd];\n            position = Math.max(position, prog.posDescription());\n        }\n        return position;\n    }\n    /**\n     * For options, get the position where the default values should start so they\n     * are aligned.\n     * @returns The position where the option default values should start.\n     */\n    posDefault() {\n        let position = -1;\n        for (let cmd in this.programs) {\n            let prog = this.programs[cmd];\n            position = Math.max(position, prog.posDefault());\n        }\n        return position;\n    }\n    /**\n     * Go through all programs and add options to the collection.\n     * @returns The options used in the programs.\n     */\n    getOptions() {\n        let allOptions = {};\n        for (let cmd in this.programs) {\n            let prog = this.programs[cmd];\n            allOptions = prog.getOptions_(allOptions);\n        }\n        return allOptions;\n    }\n    /**\n     * Get the options used by the programs and create the minimist options\n     * to ensure that minimist parses the values properly.\n     * @returns The options for minimist.\n     */\n    getMinimistOptions() {\n        let allOptions = this.getOptions();\n        let minimistOptions = {};\n        let minimistBoolean = [];\n        let minimistString = [];\n        let minimistNumber = [];\n        let minimistDefault = {};\n        for (let opt in allOptions) {\n            let option = allOptions[opt];\n            if (option.type === 'boolean') {\n                minimistBoolean.push(option.opt);\n            }\n            else if (option.type === 'string') {\n                minimistString.push(option.opt);\n            }\n            else if (option.type === 'number') {\n                minimistNumber.push(option.opt);\n            }\n            if (typeof option.defaultValue !== 'undefined') {\n                minimistDefault[option.opt] = option.defaultValue;\n            }\n        }\n        minimistOptions['boolean'] = minimistBoolean;\n        minimistOptions['string'] = minimistString;\n        minimistOptions['number'] = minimistNumber;\n        minimistOptions['default'] = minimistDefault;\n        return minimistOptions;\n    }\n}\nexports.Cli = Cli;\n//# sourceMappingURL=cli.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/cli/options.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Option {\n    constructor(opt, description, type, defaultValue) {\n        this.opt = opt;\n        this.description = description;\n        this.type = type;\n        if (defaultValue != null) {\n            this.defaultValue = defaultValue;\n        }\n    }\n    getValue_() {\n        if (typeof this.value !== 'undefined') {\n            return this.value;\n        }\n        else {\n            return this.defaultValue;\n        }\n    }\n    getNumber() {\n        let value = this.getValue_();\n        if (value != null && (typeof value === 'number' || typeof value === 'string')) {\n            return +value;\n        }\n        else {\n            return null;\n        }\n    }\n    getString() {\n        let value = this.getValue_();\n        if (value != null) {\n            return '' + this.getValue_();\n        }\n        else {\n            return '';\n        }\n    }\n    getBoolean() {\n        let value = this.getValue_();\n        if (value != null) {\n            if (typeof value === 'string') {\n                return !(value === '0' || value === 'false');\n            }\n            else if (typeof value === 'number') {\n                return value !== 0;\n            }\n            else {\n                return value;\n            }\n        }\n        return false;\n    }\n}\nexports.Option = Option;\nfunction unparseOptions(options) {\n    var args = [];\n    for (let name in options) {\n        let value = options[name].getValue_();\n        if (value !== options[name].defaultValue) {\n            args.push('--' + name, '' + value);\n        }\n    }\n    return args;\n}\nexports.unparseOptions = unparseOptions;\n;\n//# sourceMappingURL=options.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/cli/programs.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst options_1 = require(\"./options\");\n/**\n * A program has a command, a description, options, and a run method\n */\nclass Program {\n    constructor() {\n        this.options = {};\n    }\n    /**\n     * Register a command and the description.\n     * @param cmd The command.\n     * @param cmdDescription The description of the command.\n     * @returns The program for method chaining.\n     */\n    command(cmd, cmdDescription) {\n        this.cmd = cmd;\n        this.cmdDescription = cmdDescription;\n        return this;\n    }\n    /**\n     * Register a new option.\n     * @param opt The option.\n     * @param description The description of the option.\n     * @param type The type of value expected: boolean, number, or string\n     * @param defaultValue The option's default value.\n     * @returns The program for method chaining.\n     */\n    option(opt, description, type, opt_defaultValue) {\n        this.options[opt] = new options_1.Option(opt, description, type, opt_defaultValue);\n        return this;\n    }\n    /**\n     * Adds an option to the program.\n     * @param option The option.\n     * @returns The program for method chaining.\n     */\n    addOption(option) {\n        this.options[option.opt] = option;\n        return this;\n    }\n    /**\n     * Registers a method that will be used to run the program.\n     * @param runMethod The method that will be used to run the program.\n     * @returns The program for method chaining.\n     */\n    action(runMethod) {\n        this.runMethod = runMethod;\n        return this;\n    }\n    /**\n     * Adds the value to the options and passes the updated options to the run\n     * method.\n     * @param args The arguments that will be parsed to run the method.\n     */\n    run(json) {\n        for (let opt in this.options) {\n            this.options[opt].value = this.getValue_(opt, json);\n        }\n        return Promise.resolve(this.runMethod(this.options));\n    }\n    getValue_(key, json) {\n        let keyList = key.split('.');\n        let tempJson = json;\n        while (keyList.length > 0) {\n            let keyItem = keyList[0];\n            if (tempJson[keyItem] != null) {\n                tempJson = tempJson[keyItem];\n                keyList = keyList.slice(1);\n            }\n            else {\n                return undefined;\n            }\n        }\n        return tempJson;\n    }\n    /**\n     * Prints the command with the description. The description will have spaces\n     * between the cmd so that the starting position is \"posDescription\". If the\n     * gap between the cmd and the description is less than MIN_SPACING or\n     * posDescription is undefined, the spacing will be MIN_SPACING.\n     *\n     * @param opt_postDescription Starting position of the description.\n     */\n    printCmd(opt_posDescription) {\n        let log = '  ' + this.cmd;\n        let spacing = Program.MIN_SPACING;\n        if (opt_posDescription) {\n            let diff = opt_posDescription - log.length;\n            if (diff < Program.MIN_SPACING) {\n                spacing = Program.MIN_SPACING;\n            }\n            else {\n                spacing = diff;\n            }\n        }\n        log += Array(spacing).join(' ') + this.cmdDescription;\n        console.log(log);\n    }\n    /**\n     * Prints the options with the option descriptions and default values.\n     * The posDescription and posDefault is the starting position for the option\n     * description. If extOptions are provided, check to see if we have already\n     * printed those options. Also, once we print the option, add them to the extOptions.\n     *\n     * @param posDescription Position to start logging the description.\n     * @param posDefault Position to start logging the default value.\n     * @param opt_extOptions A collection of options that will be updated.\n     */\n    printOptions(posDescription, posDefault, opt_extOptions) {\n        for (let opt in this.options) {\n            // we have already logged it\n            if (opt_extOptions && opt_extOptions[opt]) {\n                continue;\n            }\n            let option = this.options[opt];\n            let log = '  --' + option.opt;\n            let spacing = Program.MIN_SPACING;\n            // description\n            let diff = posDescription - log.length;\n            if (diff < Program.MIN_SPACING) {\n                spacing = Program.MIN_SPACING;\n            }\n            else {\n                spacing = diff;\n            }\n            log += Array(spacing).join(' ') + option.description;\n            // default value\n            if (option.defaultValue) {\n                spacing = Program.MIN_SPACING;\n                let diff = posDefault - log.length - 1;\n                if (diff <= Program.MIN_SPACING) {\n                    spacing = Program.MIN_SPACING;\n                }\n                else {\n                    spacing = diff;\n                }\n                log += Array(spacing).join(' ');\n                log += '[default: ' + option.defaultValue + ']';\n            }\n            console.log(log);\n            if (opt_extOptions) {\n                opt_extOptions[option.opt] = option;\n            }\n        }\n    }\n    /**\n     * Assuming that the this program can run by itself, to print out the program's\n     * help. Also assuming that the commands are called cmd-run and cmd-help.\n     */\n    printHelp() {\n        console.log('\\n' +\n            'Usage:        ' + this.cmd + ' [options]\\n' +\n            '              ' + this.cmd + ' help\\n' +\n            'Description:  ' + this.cmdDescription + '\\n');\n        console.log('Options:');\n        this.printOptions(this.posDescription(), this.posDefault());\n    }\n    posDescription() {\n        return this.lengthOf_('opt') + 2 * Program.MIN_SPACING;\n    }\n    posDefault() {\n        return this.posDescription() + this.lengthOf_('description') + Program.MIN_SPACING;\n    }\n    lengthOf_(param) {\n        let maxLength = -1;\n        for (let opt in this.options) {\n            let option = this.options[opt];\n            if (param === 'description') {\n                maxLength = Math.max(maxLength, option.description.length);\n            }\n            else if (param === 'opt') {\n                maxLength = Math.max(maxLength, option.opt.length);\n            }\n        }\n        return maxLength;\n    }\n    /**\n     * Create a collection of options used by this program.\n     * @returns The options used in the programs.\n     */\n    getOptions_(allOptions) {\n        for (let opt in this.options) {\n            allOptions[opt] = this.options[opt];\n        }\n        return allOptions;\n    }\n    /**\n     * Get the options used by the program and create the minimist options\n     * to ensure that minimist parses the values properly.\n     * @returns The options for minimist.\n     */\n    getMinimistOptions() {\n        let allOptions = {};\n        allOptions = this.getOptions_(allOptions);\n        let minimistOptions = {};\n        let minimistBoolean = [];\n        let minimistString = [];\n        let minimistNumber = [];\n        let minimistDefault = {};\n        for (let opt in allOptions) {\n            let option = allOptions[opt];\n            if (option.type === 'boolean') {\n                minimistBoolean.push(option.opt);\n            }\n            else if (option.type === 'string') {\n                minimistString.push(option.opt);\n            }\n            else if (option.type === 'number') {\n                minimistNumber.push(option.opt);\n            }\n            if (typeof option.defaultValue !== 'undefined') {\n                minimistDefault[option.opt] = option.defaultValue;\n            }\n        }\n        minimistOptions['boolean'] = minimistBoolean;\n        minimistOptions['string'] = minimistString;\n        minimistOptions['number'] = minimistNumber;\n        minimistOptions['default'] = minimistDefault;\n        return minimistOptions;\n    }\n}\nProgram.MIN_SPACING = 4;\nexports.Program = Program;\n//# sourceMappingURL=programs.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/cli/logger.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n// Will use chalk if chalk is available to add color to console logging\nlet chalk;\nlet printRed;\nlet printYellow;\nlet printGray;\ntry {\n    chalk = require('chalk');\n    printRed = chalk.red;\n    printYellow = chalk.yellow;\n    printGray = chalk.gray;\n}\ncatch (e) {\n    printRed = printYellow = printGray = (msg) => {\n        return msg;\n    };\n}\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\n    LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"DEBUG\"] = 3] = \"DEBUG\";\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\nvar WriteTo;\n(function (WriteTo) {\n    WriteTo[WriteTo[\"CONSOLE\"] = 0] = \"CONSOLE\";\n    WriteTo[WriteTo[\"FILE\"] = 1] = \"FILE\";\n    WriteTo[WriteTo[\"BOTH\"] = 2] = \"BOTH\";\n    WriteTo[WriteTo[\"NONE\"] = 3] = \"NONE\";\n})(WriteTo = exports.WriteTo || (exports.WriteTo = {}));\nlet logFile = 'webdriver.log'; // the default log file name\n/**\n * Logger class adds timestamp output, log levels, and identifiers to help\n * when debugging. Also could write to console, file, both, or none.\n */\nclass Logger {\n    /**\n     * Creates a logger instance with an ID for the logger.\n     * @constructor\n     */\n    constructor(id) {\n        this.id = id;\n    }\n    /**\n     * Set up the write location. If writing to a file, get the file descriptor.\n     * @param writeTo The enum for where to write the logs.\n     * @param opt_logFile An optional parameter to override the log file location.\n     */\n    static setWrite(writeTo, opt_logFile) {\n        if (opt_logFile) {\n            logFile = opt_logFile;\n        }\n        Logger.writeTo = writeTo;\n        if (Logger.writeTo == WriteTo.FILE || Logger.writeTo == WriteTo.BOTH) {\n            Logger.fd = fs.openSync(path.resolve(logFile), 'a');\n            Logger.firstWrite = false;\n        }\n    }\n    /**\n     * Log INFO\n     * @param ...msgs multiple arguments to be logged.\n     */\n    info(...msgs) {\n        this.log_(LogLevel.INFO, msgs);\n    }\n    /**\n     * Log DEBUG\n     * @param ...msgs multiple arguments to be logged.\n     */\n    debug(...msgs) {\n        this.log_(LogLevel.DEBUG, msgs);\n    }\n    /**\n     * Log WARN\n     * @param ...msgs multiple arguments to be logged.\n     */\n    warn(...msgs) {\n        this.log_(LogLevel.WARN, msgs);\n    }\n    /**\n     * Log ERROR\n     * @param ...msgs multiple arguments to be logged.\n     */\n    error(...msgs) {\n        this.log_(LogLevel.ERROR, msgs);\n    }\n    /**\n     * For the log level set, check to see if the messages should be logged.\n     * @param logLevel The log level of the message.\n     * @param msgs The messages to be logged\n     */\n    log_(logLevel, msgs) {\n        switch (Logger.logLevel) {\n            case LogLevel.ERROR:\n                if (logLevel <= LogLevel.ERROR) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            case LogLevel.WARN:\n                if (logLevel <= LogLevel.WARN) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            case LogLevel.INFO:\n                if (logLevel <= LogLevel.INFO) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            case LogLevel.DEBUG:\n                if (logLevel <= LogLevel.DEBUG) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            default:\n                throw new Error('Log level undefined');\n        }\n    }\n    /**\n     * Format with timestamp, log level, identifier, and message and log to\n     * specified medium (console, file, both, none).\n     * @param logLevel The log level of the message.\n     * @param msgs The messages to be logged.\n     */\n    print_(logLevel, msgs) {\n        let consoleLog = '';\n        let fileLog = '';\n        if (Logger.showTimestamp) {\n            consoleLog += Logger.timestamp_(WriteTo.CONSOLE);\n            fileLog += Logger.timestamp_(WriteTo.FILE);\n        }\n        consoleLog += Logger.level_(logLevel, this.id, WriteTo.CONSOLE);\n        fileLog += Logger.level_(logLevel, this.id, WriteTo.FILE);\n        if (Logger.showId) {\n            consoleLog += Logger.id_(logLevel, this.id, WriteTo.CONSOLE);\n            fileLog += Logger.id_(logLevel, this.id, WriteTo.FILE);\n        }\n        consoleLog += ' -';\n        fileLog += ' - ';\n        switch (Logger.writeTo) {\n            case WriteTo.CONSOLE:\n                msgs.unshift(consoleLog);\n                console.log.apply(console, msgs);\n                break;\n            case WriteTo.FILE:\n                // for the first line written to the file, add a space\n                if (!Logger.firstWrite) {\n                    fs.writeSync(Logger.fd, '\\n');\n                    Logger.firstWrite = true;\n                }\n                fileLog += ' ' + Logger.msgToFile_(msgs);\n                fs.writeSync(Logger.fd, fileLog + '\\n');\n                break;\n            case WriteTo.BOTH:\n                // for the first line written to the file, add a space\n                if (!Logger.firstWrite) {\n                    fs.writeSync(Logger.fd, '\\n');\n                    Logger.firstWrite = true;\n                }\n                fileLog += ' ' + Logger.msgToFile_(msgs);\n                fs.writeSync(Logger.fd, fileLog + '\\n');\n                msgs.unshift(consoleLog);\n                console.log.apply(console, msgs);\n                break;\n            case WriteTo.NONE:\n                break;\n        }\n    }\n    /**\n     * Get a timestamp formatted with [hh:mm:ss]\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted timestamp\n     */\n    static timestamp_(writeTo) {\n        let d = new Date();\n        let ts = '[';\n        let hours = d.getHours() < 10 ? '0' + d.getHours() : d.getHours();\n        let minutes = d.getMinutes() < 10 ? '0' + d.getMinutes() : d.getMinutes();\n        let seconds = d.getSeconds() < 10 ? '0' + d.getSeconds() : d.getSeconds();\n        if (writeTo == WriteTo.CONSOLE) {\n            ts += printGray(hours + ':' + minutes + ':' + seconds) + ']';\n        }\n        else {\n            ts += hours + ':' + minutes + ':' + seconds + ']';\n        }\n        ts += ' ';\n        return ts;\n    }\n    /**\n     * Get the identifier of the logger as '/<id>'\n     * @param logLevel The log level of the message.\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted id\n     */\n    static id_(logLevel, id, writeTo) {\n        let level = LogLevel[logLevel].toString();\n        if (writeTo === WriteTo.FILE) {\n            return '/' + id;\n        }\n        else if (logLevel === LogLevel.ERROR) {\n            return printRed('/' + id);\n        }\n        else if (logLevel === LogLevel.WARN) {\n            return printYellow('/' + id);\n        }\n        else {\n            return '/' + id;\n        }\n    }\n    /**\n     * Get the log level formatted with the first letter. For info, it is I.\n     * @param logLevel The log level of the message.\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted log level\n     */\n    static level_(logLevel, id, writeTo) {\n        let level = LogLevel[logLevel].toString();\n        if (writeTo === WriteTo.FILE) {\n            return level[0];\n        }\n        else if (logLevel === LogLevel.ERROR) {\n            return printRed(level[0]);\n        }\n        else if (logLevel === LogLevel.WARN) {\n            return printYellow(level[0]);\n        }\n        else {\n            return level[0];\n        }\n    }\n    /**\n     * Convert the list of messages to a single string message.\n     * @param msgs The list of messages.\n     * @return The string of the formatted messages\n     */\n    static msgToFile_(msgs) {\n        let log = '';\n        for (let pos = 0; pos < msgs.length; pos++) {\n            let msg = msgs[pos];\n            let ret;\n            if (typeof msg === 'object') {\n                ret = JSON.stringify(msg);\n            }\n            else {\n                ret = msg;\n            }\n            if (pos !== msgs.length - 1) {\n                ret += ' ';\n            }\n            log += ret;\n        }\n        return log;\n    }\n}\nLogger.logLevel = LogLevel.INFO;\nLogger.showTimestamp = true;\nLogger.showId = true;\nLogger.writeTo = WriteTo.CONSOLE;\nLogger.firstWrite = false;\nexports.Logger = Logger;\n//# sourceMappingURL=logger.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/cmds/clean.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst minimist = require(\"minimist\");\nconst path = require(\"path\");\nconst cli_1 = require(\"../cli\");\nconst config_1 = require(\"../config\");\nconst files_1 = require(\"../files\");\nconst Opt = require(\"./\");\nconst opts_1 = require(\"./opts\");\nlet prog = new cli_1.Program()\n    .command('clean', 'removes all downloaded driver files from the out_dir')\n    .action(clean)\n    .addOption(opts_1.Opts[Opt.OUT_DIR]);\nexports.program = prog;\n// stand alone runner\nlet argv = minimist(process.argv.slice(2), prog.getMinimistOptions());\nif (argv._[0] === 'clean-run') {\n    prog.run(JSON.parse(JSON.stringify(argv)));\n}\nelse if (argv._[0] === 'clean-help') {\n    prog.printHelp();\n}\n/**\n * Parses the options and cleans the output directory of binaries.\n * @param: options\n */\nfunction clean(options) {\n    let outputDir = config_1.Config.getSeleniumDir();\n    if (options[Opt.OUT_DIR].getString()) {\n        if (path.isAbsolute(options[Opt.OUT_DIR].getString())) {\n            outputDir = options[Opt.OUT_DIR].getString();\n        }\n        else {\n            outputDir = path.resolve(config_1.Config.getBaseDir(), options[Opt.OUT_DIR].getString());\n        }\n    }\n    files_1.FileManager.removeExistingFiles(outputDir);\n}\n//# sourceMappingURL=clean.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/config.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst cli_1 = require(\"./cli\");\nlet logger = new cli_1.Logger('config');\n/**\n * The configuration for webdriver-manager\n *\n * The config.json, package.json, and selenium directory are found in the\n * same location at the root directory in webdriver-manager.\n *\n */\nclass Config {\n    static osArch() {\n        return Config.osArch_;\n    }\n    static osType() {\n        return Config.osType_;\n    }\n    static noProxy() {\n        return Config.noProxy_;\n    }\n    static httpProxy() {\n        return Config.httpProxy_;\n    }\n    static httpsProxy() {\n        return Config.httpsProxy_;\n    }\n    static getConfigFile_() {\n        return path.resolve(Config.dir, '..', Config.configFile);\n    }\n    static getPackageFile_() {\n        return path.resolve(Config.dir, '..', Config.packageFile);\n    }\n    static getSeleniumDir() {\n        return path.resolve(Config.dir, '..', '..', 'selenium/');\n    }\n    static getBaseDir() {\n        return path.resolve(Config.dir, '..', '..');\n    }\n    /**\n     * Get the binary versions from the configuration file.\n     * @returns A map of the versions defined in the configuration file.\n     */\n    static binaryVersions() {\n        let configFile = require(Config.getConfigFile_());\n        let configVersions = {};\n        configVersions.selenium = configFile.webdriverVersions.selenium;\n        configVersions.chrome = configFile.webdriverVersions.chromedriver;\n        configVersions.gecko = configFile.webdriverVersions.geckodriver;\n        configVersions.ie = configFile.webdriverVersions.iedriver;\n        configVersions.android = configFile.webdriverVersions.androidsdk;\n        configVersions.appium = configFile.webdriverVersions.appium;\n        return configVersions;\n    }\n    /**\n     * Get the CDN urls from the configuration file.\n     * @returns A map of the CDN versions defined in the configuration file.\n     */\n    static cdnUrls() {\n        let configFile = require(Config.getConfigFile_());\n        let configCdnUrls = {};\n        configCdnUrls.selenium = configFile.cdnUrls.selenium;\n        configCdnUrls.chrome = configFile.cdnUrls.chromedriver;\n        configCdnUrls.gecko = configFile.cdnUrls.geckodriver;\n        configCdnUrls.ie = configFile.cdnUrls.iedriver;\n        configCdnUrls.android = configFile.cdnUrls.androidsdk;\n        return configCdnUrls;\n    }\n    /**\n     * Get the package version.\n     */\n    static getVersion() {\n        let packageFile = require(Config.getPackageFile_());\n        return packageFile.version;\n    }\n}\nConfig.configFile = 'config.json';\nConfig.packageFile = 'package.json';\nConfig.nodeModuleName = 'webdriver-manager';\nConfig.cwd = process.cwd();\nConfig.parentPath = path.resolve(Config.cwd, '..');\nConfig.dir = __dirname;\nConfig.folder = Config.cwd.replace(Config.parentPath, '').substring(1);\nConfig.isProjectVersion = Config.folder === Config.nodeModuleName;\nConfig.isLocalVersion = false;\nConfig.osArch_ = os.arch();\nConfig.osType_ = os.type();\nConfig.noProxy_ = process.env.NO_PROXY || process.env.no_proxy;\nConfig.httpsProxy_ = process.env.HTTPS_PROXY || process.env.https_proxy;\nConfig.httpProxy_ = process.env.HTTP_PROXY || process.env.http_proxy;\nexports.Config = Config;\n//# sourceMappingURL=config.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/files/index.js":"\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./downloaded_binary\"));\n__export(require(\"./downloader\"));\n__export(require(\"./file_manager\"));\n//# sourceMappingURL=index.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/files/downloaded_binary.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst binaries_1 = require(\"../binaries\");\n/**\n * The downloaded binary is the binary with the list of versions downloaded.\n */\nclass DownloadedBinary extends binaries_1.Binary {\n    constructor(binary) {\n        super();\n        this.versions = [];\n        this.binary = binary;\n        this.name = binary.name;\n        this.versionCustom = binary.versionCustom;\n    }\n    id() {\n        return this.binary.id();\n    }\n    prefix() {\n        return null;\n    }\n    suffix() {\n        return null;\n    }\n    getUrl() {\n        return null;\n    }\n    getVersionList() {\n        return null;\n    }\n}\nexports.DownloadedBinary = DownloadedBinary;\n//# sourceMappingURL=downloaded_binary.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/binaries/index.js":"\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./android_sdk\"));\n__export(require(\"./appium\"));\n__export(require(\"./binary\"));\n__export(require(\"./chrome_driver\"));\n__export(require(\"./gecko_driver\"));\n__export(require(\"./iedriver\"));\n__export(require(\"./standalone\"));\n//# sourceMappingURL=index.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/binaries/android_sdk.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst path = require(\"path\");\nconst rimraf = require(\"rimraf\");\nconst config_1 = require(\"../config\");\nconst utils_1 = require(\"../utils\");\nconst binary_1 = require(\"./binary\");\nfunction getAndroidArch() {\n    switch (config_1.Config.osArch()) {\n        case 'arm':\n            return 'armeabi-v7a';\n        case 'arm64':\n            return 'arm64-v8a';\n        case 'x86':\n        case 'x32':\n        case 'ia32':\n        case 'ppc':\n            return 'x86';\n        case 'x86-64':\n        case 'x64':\n        case 'ia64':\n        case 'ppc64':\n            return 'x86_64';\n        default:\n            return config_1.Config.osArch();\n    }\n}\n/**\n * The android sdk binary.\n */\nclass AndroidSDK extends binary_1.Binary {\n    constructor(alternateCDN) {\n        super(alternateCDN || config_1.Config.cdnUrls().android);\n        this.name = 'android-sdk';\n        this.versionCustom = AndroidSDK.versionDefault;\n    }\n    id() {\n        return AndroidSDK.id;\n    }\n    prefix() {\n        return 'android-sdk_r';\n    }\n    suffix() {\n        if (this.ostype === 'Darwin') {\n            return '-macosx.zip';\n        }\n        else if (this.ostype === 'Linux') {\n            return '-linux.tgz';\n        }\n        else if (this.ostype === 'Windows_NT') {\n            return '-windows.zip';\n        }\n    }\n    getUrl() {\n        return Promise.resolve({ url: this.cdn + this.filename(), version: this.versionCustom });\n    }\n    getVersionList() {\n        return null;\n    }\n    url(ostype) {\n        return this.cdn + this.filename();\n    }\n    zipContentName() {\n        if (this.ostype === 'Darwin') {\n            return this.name + '-macosx';\n        }\n        else if (this.ostype === 'Linux') {\n            return this.name + '-linux';\n        }\n        else if (this.ostype === 'Windows_NT') {\n            return this.name + '-windows';\n        }\n    }\n    executableSuffix() {\n        return '';\n    }\n    remove(sdkPath) {\n        try {\n            let avds = require(path.resolve(sdkPath, 'available_avds.json'));\n            let version = path.basename(sdkPath).slice(this.prefix().length);\n            avds.forEach((avd) => {\n                utils_1.spawnSync(path.resolve(sdkPath, 'tools', 'android'), ['delete', 'avd', '-n', avd + '-v' + version + '-wd-manager']);\n            });\n        }\n        catch (e) {\n        }\n        rimraf.sync(sdkPath);\n    }\n}\nAndroidSDK.os = [binary_1.OS.Windows_NT, binary_1.OS.Linux, binary_1.OS.Darwin];\nAndroidSDK.id = 'android';\nAndroidSDK.versionDefault = config_1.Config.binaryVersions().android;\nAndroidSDK.isDefault = false;\nAndroidSDK.DEFAULT_API_LEVELS = '24';\nAndroidSDK.DEFAULT_ARCHITECTURES = getAndroidArch();\nAndroidSDK.DEFAULT_PLATFORMS = 'google_apis';\nAndroidSDK.VERSIONS = {\n    // Before 24 is not supported\n    24: '7.0',\n    25: '7.1'\n};\nexports.AndroidSDK = AndroidSDK;\n//# sourceMappingURL=android_sdk.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/utils.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst child_process = require(\"child_process\");\nconst fs = require(\"fs\");\nconst http = require(\"http\");\nconst path = require(\"path\");\nconst config_1 = require(\"./config\");\nfunction spawnFactory(sync) {\n    return (cmd, args, stdio, opts) => {\n        if ((config_1.Config.osType() === 'Windows_NT') && (cmd.slice(-4) !== '.exe')) {\n            if (fs.existsSync(cmd + '.exe')) {\n                cmd += '.exe';\n            }\n            else {\n                args = ['/c'].concat([cmd], args);\n                cmd = 'cmd';\n            }\n        }\n        if (stdio) {\n            opts = opts || {};\n            opts.stdio = stdio;\n        }\n        if (sync) {\n            return child_process.spawnSync(cmd, args, opts);\n        }\n        else {\n            return child_process.spawn(cmd, args, opts);\n        }\n    };\n}\nexports.spawn = spawnFactory(false);\nexports.spawnSync = spawnFactory(true);\nfunction request(method, port, path, timeout, data) {\n    let headers = {};\n    let hasContent = data && ((method == 'POST') || (method == 'PUT'));\n    if (hasContent) {\n        data = data ? JSON.stringify(data) : '';\n        headers['Content-Length'] = data.length;\n        headers['Content-Type'] = 'application/json;charset=UTF-8';\n    }\n    return new Promise((resolve, reject) => {\n        let unexpectedEnd = () => {\n            reject({ code: 'UNKNOWN', message: 'Request ended unexpectedly' });\n        };\n        let req = http.request({ port: parseInt(port), method: method, path: path, headers: headers }, (res) => {\n            req.removeListener('end', unexpectedEnd);\n            if (res.statusCode !== 200) {\n                reject({ code: res.statusCode, message: res.statusMessage });\n            }\n            else {\n                let buffer = [];\n                res.on('data', buffer.push.bind(buffer));\n                res.on('end', () => {\n                    resolve(buffer.join('').replace(/\\0/g, ''));\n                });\n            }\n        });\n        if (timeout) {\n            req.setTimeout(timeout, () => {\n                reject({ code: 'TIMEOUT', message: 'Request timed out' });\n            });\n        }\n        req.on('error', reject);\n        req.on('end', unexpectedEnd);\n        if (hasContent) {\n            req.write(data);\n        }\n        req.end();\n    });\n}\nexports.request = request;\nfunction adb(sdkPath, port, command, timeout, args) {\n    return new Promise((resolve, reject) => {\n        let child = exports.spawn(path.resolve(sdkPath, 'platform-tools', 'adb'), ['-s', 'emulator-' + port, command].concat(args || []), 'pipe');\n        let done = false;\n        let buffer = [];\n        child.stdout.on('data', buffer.push.bind(buffer));\n        child.on('error', (err) => {\n            if (!done) {\n                done = true;\n                reject(err);\n            }\n        });\n        child.on('exit', (code, signal) => {\n            if (!done) {\n                done = true;\n                if (code === 0) {\n                    resolve(buffer.join(''));\n                }\n                else {\n                    reject({\n                        code: code,\n                        message: 'abd command \"' + command + '\" ' +\n                            (signal ? 'received signal ' + signal : 'returned with a non-zero exit code') +\n                            'for emulator-' + port\n                    });\n                }\n            }\n        });\n        if (timeout) {\n            setTimeout(() => {\n                if (!done) {\n                    done = true;\n                    child.kill();\n                    reject({\n                        code: 'TIMEOUT',\n                        message: 'adb command \"' + command + '\" timed out for emulator-' + port\n                    });\n                }\n            }, timeout);\n        }\n    });\n}\nexports.adb = adb;\n//# sourceMappingURL=utils.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/binaries/binary.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst config_1 = require(\"../config\");\n/**\n * operating system enum\n */\nvar OS;\n(function (OS) {\n    OS[OS[\"Windows_NT\"] = 0] = \"Windows_NT\";\n    OS[OS[\"Linux\"] = 1] = \"Linux\";\n    OS[OS[\"Darwin\"] = 2] = \"Darwin\";\n})(OS = exports.OS || (exports.OS = {}));\nclass Binary {\n    constructor(opt_alternativeCdn) {\n        this.ostype = config_1.Config.osType();\n        this.osarch = config_1.Config.osArch();\n        this.cdn = opt_alternativeCdn;\n    }\n    executableSuffix() {\n        if (this.ostype == 'Windows_NT') {\n            return '.exe';\n        }\n        else {\n            return '';\n        }\n    }\n    version() {\n        return this.versionCustom;\n    }\n    filename() {\n        return this.prefix() + this.version() + this.suffix();\n    }\n    /**\n     * @param ostype The operating system.\n     * @returns The file name for the executable.\n     */\n    executableFilename() {\n        return this.prefix() + this.version() + this.executableSuffix();\n    }\n    /**\n     * Gets the url to download the file set by the version. This will use the XML if available.\n     * If not, it will download from an existing url.\n     *\n     * @param {string} version The version we are looking for. This could also be 'latest'.\n     * @param {opt_proxy} string Option to get proxy URL.\n     * @param {opt_ignoreSSL} boolean Option to ignore SSL.\n     */\n    getUrl(version, opt_proxy, opt_ignoreSSL) {\n        this.opt_proxy = opt_proxy == undefined ? this.opt_proxy : opt_proxy;\n        this.opt_ignoreSSL = opt_ignoreSSL == undefined ? this.opt_ignoreSSL : opt_ignoreSSL;\n        if (this.configSource) {\n            this.configSource.opt_proxy = this.opt_proxy;\n            this.configSource.opt_ignoreSSL = this.opt_ignoreSSL;\n        }\n        if (this.alternativeDownloadUrl != null) {\n            return Promise.resolve({ url: '', version: '' });\n        }\n        else {\n            return this.getVersionList().then(() => {\n                version = version || config_1.Config.binaryVersions()[this.id()];\n                return this.configSource.getUrl(version).then(binaryUrl => {\n                    this.versionCustom = binaryUrl.version;\n                    return { url: binaryUrl.url, version: binaryUrl.version };\n                });\n            });\n        }\n    }\n    /**\n     * Delete an instance of this binary from the file system\n     */\n    remove(filename) {\n        fs.unlinkSync(filename);\n    }\n    /**\n     * @param ostype The operating system.\n     * @returns The file name for the file inside the downloaded zip file\n     */\n    zipContentName() {\n        return this.name + this.executableSuffix();\n    }\n}\nexports.Binary = Binary;\n//# sourceMappingURL=binary.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/binaries/appium.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst rimraf = require(\"rimraf\");\nconst config_1 = require(\"../config\");\nconst binary_1 = require(\"./binary\");\n/**\n * The appium binary.\n */\nclass Appium extends binary_1.Binary {\n    constructor(alternateCDN) {\n        super(alternateCDN || config_1.Config.cdnUrls().appium);\n        this.name = 'appium';\n        this.versionCustom = Appium.versionDefault;\n    }\n    id() {\n        return Appium.id;\n    }\n    prefix() {\n        return 'appium-';\n    }\n    suffix() {\n        return '';\n    }\n    executableSuffix() {\n        return '';\n    }\n    getUrl(version) {\n        return Promise.resolve({ url: '', version: this.versionCustom });\n    }\n    getVersionList() {\n        return null;\n    }\n    remove(sdkPath) {\n        rimraf.sync(sdkPath);\n    }\n}\nAppium.os = [binary_1.OS.Windows_NT, binary_1.OS.Linux, binary_1.OS.Darwin];\nAppium.id = 'appium';\nAppium.versionDefault = config_1.Config.binaryVersions().appium;\nAppium.isDefault = false;\nexports.Appium = Appium;\n//# sourceMappingURL=appium.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/binaries/chrome_driver.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst config_1 = require(\"../config\");\nconst binary_1 = require(\"./binary\");\nconst chrome_xml_1 = require(\"./chrome_xml\");\nclass ChromeDriver extends binary_1.Binary {\n    constructor(opt_alternativeCdn) {\n        super(opt_alternativeCdn || config_1.Config.cdnUrls().chrome);\n        this.configSource = new chrome_xml_1.ChromeXml();\n        this.name = 'chromedriver';\n        this.versionDefault = ChromeDriver.versionDefault;\n        this.versionCustom = this.versionDefault;\n    }\n    id() {\n        return ChromeDriver.id;\n    }\n    prefix() {\n        return 'chromedriver_';\n    }\n    suffix() {\n        return '.zip';\n    }\n    getVersionList() {\n        // If an alternative cdn is set, return an empty list.\n        if (this.alternativeDownloadUrl != null) {\n            Promise.resolve([]);\n        }\n        else {\n            return this.configSource.getVersionList();\n        }\n    }\n}\nChromeDriver.id = 'chrome';\nChromeDriver.isDefault = true;\nChromeDriver.os = [binary_1.OS.Windows_NT, binary_1.OS.Linux, binary_1.OS.Darwin];\nChromeDriver.versionDefault = config_1.Config.binaryVersions().chrome;\nexports.ChromeDriver = ChromeDriver;\n//# sourceMappingURL=chrome_driver.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/binaries/chrome_xml.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst semver = require(\"semver\");\nconst config_1 = require(\"../config\");\nconst config_source_1 = require(\"./config_source\");\nclass ChromeXml extends config_source_1.XmlConfigSource {\n    constructor() {\n        super('chrome', config_1.Config.cdnUrls()['chrome']);\n    }\n    getUrl(version) {\n        if (version === 'latest') {\n            return this.getLatestChromeDriverVersion();\n        }\n        else {\n            return this.getSpecificChromeDriverVersion(version);\n        }\n    }\n    /**\n     * Get a list of chrome drivers paths available for the configuration OS type and architecture.\n     */\n    getVersionList() {\n        return this.getXml().then(xml => {\n            let versionPaths = [];\n            let osType = this.getOsTypeName();\n            for (let content of xml.ListBucketResult.Contents) {\n                let contentKey = content.Key[0];\n                // Filter for 32-bit devices, make sure x64 is not an option\n                if (this.osarch === 'x64' || !contentKey.includes('64')) {\n                    // Filter for only the osType\n                    if (contentKey.includes(osType)) {\n                        versionPaths.push(contentKey);\n                    }\n                }\n            }\n            return versionPaths;\n        });\n    }\n    /**\n     * Helper method, gets the ostype and gets the name used by the XML\n     */\n    getOsTypeName() {\n        // Get the os type name.\n        if (this.ostype === 'Darwin') {\n            return 'mac';\n        }\n        else if (this.ostype === 'Windows_NT') {\n            return 'win';\n        }\n        else {\n            return 'linux';\n        }\n    }\n    /**\n     * Gets the latest item from the XML.\n     */\n    getLatestChromeDriverVersion() {\n        return this.getVersionList().then(list => {\n            let chromedriverVersion = null;\n            let latest = '';\n            let latestVersion = '';\n            for (let item of list) {\n                // Get a semantic version\n                let version = item.split('/')[0];\n                if (semver.valid(version) == null) {\n                    version += '.0';\n                    if (semver.valid(version)) {\n                        // First time: use the version found.\n                        if (chromedriverVersion == null) {\n                            chromedriverVersion = version;\n                            latest = item;\n                            latestVersion = item.split('/')[0];\n                        }\n                        else if (semver.gt(version, chromedriverVersion)) {\n                            // After the first time, make sure the semantic version is greater.\n                            chromedriverVersion = version;\n                            latest = item;\n                            latestVersion = item.split('/')[0];\n                        }\n                        else if (version === chromedriverVersion) {\n                            // If the semantic version is the same, check os arch.\n                            // For 64-bit systems, prefer the 64-bit version.\n                            if (this.osarch === 'x64') {\n                                if (item.includes(this.getOsTypeName() + '64')) {\n                                    latest = item;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return { url: config_1.Config.cdnUrls().chrome + latest, version: latestVersion };\n        });\n    }\n    /**\n     * Gets a specific item from the XML.\n     */\n    getSpecificChromeDriverVersion(inputVersion) {\n        return this.getVersionList().then(list => {\n            let itemFound = '';\n            let specificVersion = semver.valid(inputVersion) ? inputVersion : inputVersion + '.0';\n            for (let item of list) {\n                // Get a semantic version.\n                let version = item.split('/')[0];\n                if (semver.valid(version) == null) {\n                    version += '.0';\n                    if (semver.valid(version)) {\n                        // Check to see if the specified version matches.\n                        if (version === specificVersion) {\n                            // When item found is null, check the os arch\n                            // 64-bit version works OR not 64-bit version and the path does not have '64'\n                            if (itemFound == '') {\n                                if (this.osarch === 'x64' ||\n                                    (this.osarch !== 'x64' && !item.includes(this.getOsTypeName() + '64'))) {\n                                    itemFound = item;\n                                }\n                            }\n                            else if (this.osarch === 'x64') {\n                                if (item.includes(this.getOsTypeName() + '64')) {\n                                    itemFound = item;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (itemFound == '') {\n                return { url: '', version: inputVersion };\n            }\n            else {\n                return { url: config_1.Config.cdnUrls().chrome + itemFound, version: inputVersion };\n            }\n        });\n    }\n}\nexports.ChromeXml = ChromeXml;\n//# sourceMappingURL=chrome_xml.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/binaries/config_source.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst request = require(\"request\");\nconst xml2js = require(\"xml2js\");\nconst config_1 = require(\"../config\");\nconst http_utils_1 = require(\"../http_utils\");\nclass ConfigSource {\n    constructor() {\n        this.ostype = config_1.Config.osType();\n        this.osarch = config_1.Config.osArch();\n        this.out_dir = config_1.Config.getSeleniumDir();\n    }\n}\nexports.ConfigSource = ConfigSource;\nclass XmlConfigSource extends ConfigSource {\n    constructor(name, xmlUrl) {\n        super();\n        this.name = name;\n        this.xmlUrl = xmlUrl;\n    }\n    getFileName() {\n        try {\n            fs.statSync(this.out_dir);\n        }\n        catch (e) {\n            fs.mkdirSync(this.out_dir);\n        }\n        return path.resolve(this.out_dir, this.name + '-response.xml');\n    }\n    getXml() {\n        let fileName = this.getFileName();\n        let content = this.readResponse();\n        if (content != null) {\n            return Promise.resolve(content);\n        }\n        return this.requestXml().then(text => {\n            let xml = this.convertXml2js(text);\n            fs.writeFileSync(fileName, text);\n            return xml;\n        });\n    }\n    readResponse() {\n        let fileName = this.getFileName();\n        try {\n            let contents = fs.readFileSync(fileName).toString();\n            let timestamp = new Date(fs.statSync(fileName).mtime).getTime();\n            let now = Date.now();\n            // 60 minutes * 60 seconds / minute * 1000 ms / second\n            if (now - (60 * 60 * 1000) < timestamp) {\n                return this.convertXml2js(contents);\n            }\n        }\n        catch (err) {\n            return null;\n        }\n    }\n    requestXml() {\n        return new Promise((resolve, reject) => {\n            let options = http_utils_1.HttpUtils.initOptions(this.xmlUrl);\n            options = http_utils_1.HttpUtils.optionsSSL(options, this.opt_ignoreSSL);\n            options = http_utils_1.HttpUtils.optionsProxy(options, this.xmlUrl, this.opt_proxy);\n            let req = request(options);\n            req.on('response', response => {\n                if (response.statusCode === 200) {\n                    // logger.info('curl -v ' + options.url);\n                    let output = '';\n                    response.on('data', (data) => {\n                        output += data;\n                    });\n                    response.on('end', () => {\n                        resolve(output);\n                    });\n                }\n                else {\n                    reject(new Error('response status code is not 200'));\n                }\n            });\n        });\n    }\n    convertXml2js(xml) {\n        let retResult = null;\n        xml2js.parseString(xml, (err, result) => {\n            retResult = result;\n        });\n        return retResult;\n    }\n}\nexports.XmlConfigSource = XmlConfigSource;\nclass JsonConfigSource extends ConfigSource {\n    constructor(name, jsonUrl) {\n        super();\n        this.name = name;\n        this.jsonUrl = jsonUrl;\n    }\n    getFileName() {\n        try {\n            fs.statSync(this.out_dir);\n        }\n        catch (e) {\n            fs.mkdirSync(this.out_dir);\n        }\n        return path.resolve(this.out_dir, this.name + '-response.json');\n    }\n}\nexports.JsonConfigSource = JsonConfigSource;\nclass GithubApiConfigSource extends JsonConfigSource {\n    constructor(name, url) {\n        super(name, url);\n    }\n    /**\n     * This is an unauthenticated request and since Github limits the rate, we will cache this\n     * to a file. { timestamp: number, response: response }. We will check the timestamp and renew\n     * this request if the file is older than an hour.\n     */\n    getJson() {\n        let fileName = this.getFileName();\n        let content = this.readResponse();\n        if (content != null) {\n            return Promise.resolve(JSON.parse(content));\n        }\n        else {\n            return this.requestJson().then(body => {\n                let json = JSON.parse(body);\n                fs.writeFileSync(fileName, JSON.stringify(json, null, '  '));\n                return json;\n            });\n        }\n    }\n    requestJson() {\n        return new Promise((resolve, reject) => {\n            let options = http_utils_1.HttpUtils.initOptions(this.jsonUrl);\n            options = http_utils_1.HttpUtils.optionsSSL(options, this.opt_ignoreSSL);\n            options = http_utils_1.HttpUtils.optionsProxy(options, this.jsonUrl, this.opt_proxy);\n            options = http_utils_1.HttpUtils.optionsHeader(options, 'Host', 'api.github.com');\n            options = http_utils_1.HttpUtils.optionsHeader(options, 'User-Agent', 'request');\n            let req = request(options);\n            req.on('response', response => {\n                if (response.statusCode === 200) {\n                    // logger.info('curl -v ' + options.url);\n                    let output = '';\n                    response.on('data', (data) => {\n                        output += data;\n                    });\n                    response.on('end', () => {\n                        resolve(output);\n                    });\n                }\n                else if (response.statusCode == 403 && response.headers['x-ratelimit-remaining'] == 0) {\n                    reject(new Error('Failed to make Github request, rate limit reached.'));\n                }\n                else {\n                    reject(new Error('response status code is not 200.  It was ' + response.statusCode));\n                }\n            });\n        });\n    }\n    readResponse() {\n        let fileName = this.getFileName();\n        try {\n            let contents = fs.readFileSync(fileName).toString();\n            let timestamp = new Date(fs.statSync(fileName).mtime).getTime();\n            let now = Date.now();\n            // 60 minutes * 60 seconds / minute * 1000 ms / second\n            if (now - (60 * 60 * 1000) < timestamp) {\n                return contents;\n            }\n        }\n        catch (err) {\n            return null;\n        }\n    }\n}\nexports.GithubApiConfigSource = GithubApiConfigSource;\n//# sourceMappingURL=config_source.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/http_utils.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst url = require(\"url\");\nconst logger_1 = require(\"./cli/logger\");\nconst config_1 = require(\"./config\");\nlet logger = new logger_1.Logger('http_utils');\nclass HttpUtils {\n    static initOptions(url, timeout) {\n        let options = {\n            url: url,\n            // default Linux can be anywhere from 20-120 seconds\n            // increasing this arbitrarily to 4 minutes\n            timeout: 240000\n        };\n        return options;\n    }\n    static optionsSSL(options, opt_ignoreSSL) {\n        if (opt_ignoreSSL) {\n            logger.info('ignoring SSL certificate');\n            options.strictSSL = !opt_ignoreSSL;\n            options.rejectUnauthorized = !opt_ignoreSSL;\n        }\n        return options;\n    }\n    static optionsProxy(options, requestUrl, opt_proxy) {\n        if (opt_proxy) {\n            options.proxy = HttpUtils.resolveProxy(requestUrl, opt_proxy);\n            if (url.parse(requestUrl).protocol === 'https:') {\n                options.url = requestUrl.replace('https:', 'http:');\n            }\n        }\n        return options;\n    }\n    static optionsHeader(options, key, value) {\n        if (options.headers == null) {\n            options.headers = {};\n        }\n        options.headers[key] = value;\n        return options;\n    }\n    /**\n     * Resolves proxy based on values set\n     * @param fileUrl The url to download the file.\n     * @param opt_proxy The proxy to connect to to download files.\n     * @return Either undefined or the proxy.\n     */\n    static resolveProxy(fileUrl, opt_proxy) {\n        let protocol = url.parse(fileUrl).protocol;\n        let hostname = url.parse(fileUrl).hostname;\n        if (opt_proxy) {\n            return opt_proxy;\n        }\n        else {\n            // If the NO_PROXY environment variable exists and matches the host name,\n            // to ignore the resolve proxy.\n            // the checks to see if it exists and equal to empty string is to help with testing\n            let noProxy = config_1.Config.noProxy();\n            if (noProxy) {\n                // array of hostnames/domain names listed in the NO_PROXY environment variable\n                let noProxyTokens = noProxy.split(',');\n                // check if the fileUrl hostname part does not end with one of the\n                // NO_PROXY environment variable's hostnames/domain names\n                for (let noProxyToken of noProxyTokens) {\n                    if (hostname.indexOf(noProxyToken) !== -1) {\n                        return undefined;\n                    }\n                }\n            }\n            // If the HTTPS_PROXY and HTTP_PROXY environment variable is set, use that as the proxy\n            if (protocol === 'https:') {\n                return config_1.Config.httpsProxy() || config_1.Config.httpProxy();\n            }\n            else if (protocol === 'http:') {\n                return config_1.Config.httpProxy();\n            }\n        }\n        return undefined;\n    }\n}\nexports.HttpUtils = HttpUtils;\n//# sourceMappingURL=http_utils.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/binaries/gecko_driver.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst config_1 = require(\"../config\");\nconst binary_1 = require(\"./binary\");\nconst gecko_driver_github_1 = require(\"./gecko_driver_github\");\nclass GeckoDriver extends binary_1.Binary {\n    constructor(opt_alternativeCdn) {\n        super(opt_alternativeCdn || config_1.Config.cdnUrls().gecko);\n        this.configSource = new gecko_driver_github_1.GeckoDriverGithub();\n        this.name = 'geckodriver';\n        this.versionDefault = GeckoDriver.versionDefault;\n        this.versionCustom = this.versionDefault;\n    }\n    id() {\n        return GeckoDriver.id;\n    }\n    prefix() {\n        return 'geckodriver-';\n    }\n    suffix() {\n        if (this.ostype === 'Windows_NT') {\n            return '.zip';\n        }\n        else {\n            return '.tar.gz';\n        }\n    }\n    getVersionList() {\n        if (this.alternativeDownloadUrl != null) {\n            return Promise.resolve([]);\n        }\n        else {\n            return this.configSource.getVersionList();\n        }\n    }\n}\nGeckoDriver.id = 'gecko';\nGeckoDriver.isDefault = true;\nGeckoDriver.os = [binary_1.OS.Windows_NT, binary_1.OS.Linux, binary_1.OS.Darwin];\nGeckoDriver.versionDefault = config_1.Config.binaryVersions().gecko;\nGeckoDriver.suffixes = {\n    'Darwin': { 'x64': '-macos.tar.gz' },\n    'Linux': { 'x64': '-linux64.tar.gz', 'ia32': '-linux32.tar.gz' },\n    'Windows_NT': {\n        'x64': '-win64.zip',\n        'ia32': '-win32.zip',\n    }\n};\nexports.GeckoDriver = GeckoDriver;\n//# sourceMappingURL=gecko_driver.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/binaries/gecko_driver_github.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst semver = require(\"semver\");\nconst config_source_1 = require(\"./config_source\");\nclass GeckoDriverGithub extends config_source_1.GithubApiConfigSource {\n    constructor() {\n        super('gecko', 'https://api.github.com/repos/mozilla/geckodriver/releases');\n    }\n    getUrl(version) {\n        if (version === 'latest') {\n            return this.getLatestGeckoDriverVersion();\n        }\n        else {\n            return this.getSpecificGeckoDrierVersion(version);\n        }\n    }\n    getVersionList() {\n        return this.getJson().then(json => {\n            let versions = [];\n            for (let i = 0; i < json.length; i++) {\n                let item = json[i];\n                versions.push(item.tag_name);\n            }\n            return versions;\n        });\n    }\n    getVersionsLookup() {\n        return this.getJson().then(json => {\n            let versionsLookup = [];\n            for (let i = 0; i < json.length; i++) {\n                let item = json[i];\n                versionsLookup.push({ version: item.tag_name, index: i });\n            }\n            return versionsLookup;\n        });\n    }\n    getLatestGeckoDriverVersion() {\n        return this.getJson().then(json => {\n            return this.getVersionsLookup().then(versionsLookup => {\n                let latest = '';\n                for (let item of versionsLookup) {\n                    let version = item.version.replace('v', '');\n                    let assetsArray = json[item.index].assets;\n                    // check to make sure the version found has the OS\n                    for (let asset of assetsArray) {\n                        if (asset.name.includes(this.oshelper())) {\n                            if (latest === '') {\n                                latest = version;\n                            }\n                            else if (semver.lt(latest, version)) {\n                                latest = version;\n                            }\n                        }\n                    }\n                }\n                return this.getSpecificGeckoDrierVersion('v' + latest);\n            });\n        });\n    }\n    getSpecificGeckoDrierVersion(inputVersion) {\n        return this.getJson().then(json => {\n            return this.getVersionsLookup().then(versionsLookup => {\n                for (let item of versionsLookup) {\n                    // Get the asset from the matching version.\n                    if (item.version === inputVersion) {\n                        let assetsArray = json[item.index].assets;\n                        for (let asset of assetsArray) {\n                            if (asset.name.includes(this.oshelper())) {\n                                return { url: asset.browser_download_url, version: inputVersion };\n                            }\n                        }\n                    }\n                }\n                return null;\n            });\n        });\n    }\n    oshelper() {\n        // Get the os type name.\n        if (this.ostype === 'Darwin') {\n            return 'macos';\n        }\n        else if (this.ostype === 'Windows_NT') {\n            return this.osarch === 'x64' ? 'win64' : 'win32';\n        }\n        else {\n            return this.osarch === 'x64' ? 'linux64' : 'linux32';\n        }\n    }\n}\nexports.GeckoDriverGithub = GeckoDriverGithub;\n//# sourceMappingURL=gecko_driver_github.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/binaries/iedriver.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst config_1 = require(\"../config\");\nconst binary_1 = require(\"./binary\");\nconst iedriver_xml_1 = require(\"./iedriver_xml\");\nclass IEDriver extends binary_1.Binary {\n    constructor(opt_alternativeCdn) {\n        super(opt_alternativeCdn || config_1.Config.cdnUrls().ie);\n        this.configSource = new iedriver_xml_1.IEDriverXml();\n        this.name = 'IEDriverServer';\n        this.versionDefault = IEDriver.versionDefault;\n        this.versionCustom = this.versionDefault;\n    }\n    id() {\n        return IEDriver.id;\n    }\n    prefix() {\n        return 'IEDriverServer';\n    }\n    suffix() {\n        return '.zip';\n    }\n    getVersionList() {\n        if (this.alternativeDownloadUrl != null) {\n            return Promise.resolve([]);\n        }\n        else {\n            return this.configSource.getVersionList();\n        }\n    }\n}\nIEDriver.id = 'ie';\nIEDriver.isDefault32 = false;\nIEDriver.isDefault64 = false;\nIEDriver.os = [binary_1.OS.Windows_NT];\nIEDriver.versionDefault = config_1.Config.binaryVersions().ie;\nexports.IEDriver = IEDriver;\n//# sourceMappingURL=iedriver.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/binaries/iedriver_xml.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst semver = require(\"semver\");\nconst config_1 = require(\"../config\");\nconst config_source_1 = require(\"./config_source\");\nclass IEDriverXml extends config_source_1.XmlConfigSource {\n    constructor() {\n        super('iedriver', config_1.Config.cdnUrls()['ie']);\n    }\n    getUrl(version) {\n        if (version === 'latest') {\n            return this.getLatestIEDriverVersion();\n        }\n        else {\n            return this.getSpecificIEDriverVersion(version);\n        }\n    }\n    getVersionList() {\n        return this.getXml().then(xml => {\n            let versionPaths = [];\n            for (let content of xml.ListBucketResult.Contents) {\n                let contentKey = content.Key[0];\n                // Filter For IEDriverServer win 32. Removing option to download x64\n                if (contentKey.includes('IEDriverServer_Win32_')) {\n                    versionPaths.push(contentKey);\n                }\n            }\n            return versionPaths;\n        });\n    }\n    getLatestIEDriverVersion() {\n        return this.getVersionList().then(list => {\n            let latestVersion = null;\n            let latest = '';\n            for (let item of list) {\n                // Get a semantic version.\n                let version = item.split('IEDriverServer_Win32_')[1].replace('.zip', '');\n                if (latestVersion == null) {\n                    // First time: use the version found.\n                    latestVersion = version;\n                    latest = item;\n                }\n                else if (semver.gt(version, latestVersion)) {\n                    // Get the latest.\n                    latestVersion = version;\n                    latest = item;\n                }\n            }\n            return { url: config_1.Config.cdnUrls().ie + latest, version: latestVersion };\n        });\n    }\n    getSpecificIEDriverVersion(inputVersion) {\n        return this.getVersionList().then(list => {\n            let itemFound = '';\n            for (let item of list) {\n                // Get a semantic version.\n                let version = item.split('IEDriverServer_Win32_')[1].replace('.zip', '');\n                // Check to see if the specified version matches.\n                let firstPath = item.split('/')[0];\n                if (version === inputVersion) {\n                    return { url: config_1.Config.cdnUrls().ie + item, version: version };\n                }\n            }\n            return { url: '', version: inputVersion };\n        });\n    }\n}\nexports.IEDriverXml = IEDriverXml;\n//# sourceMappingURL=iedriver_xml.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/binaries/standalone.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst config_1 = require(\"../config\");\nconst binary_1 = require(\"./binary\");\nconst standalone_xml_1 = require(\"./standalone_xml\");\nclass Standalone extends binary_1.Binary {\n    constructor(opt_alternativeCdn) {\n        super(opt_alternativeCdn || config_1.Config.cdnUrls().selenium);\n        this.configSource = new standalone_xml_1.StandaloneXml();\n        this.name = 'selenium standalone';\n        this.versionDefault = Standalone.versionDefault;\n        this.versionCustom = this.versionDefault;\n    }\n    id() {\n        return Standalone.id;\n    }\n    prefix() {\n        return 'selenium-server-standalone-';\n    }\n    suffix() {\n        return '.jar';\n    }\n    executableSuffix() {\n        return '.jar';\n    }\n    getVersionList() {\n        // If an alternative cdn is set, return an empty list.\n        if (this.alternativeDownloadUrl != null) {\n            return Promise.resolve([]);\n        }\n        else {\n            return this.configSource.getVersionList();\n        }\n    }\n}\nStandalone.id = 'standalone';\nStandalone.isDefault = true;\nStandalone.os = [binary_1.OS.Windows_NT, binary_1.OS.Linux, binary_1.OS.Darwin];\nStandalone.versionDefault = config_1.Config.binaryVersions().selenium;\nexports.Standalone = Standalone;\n//# sourceMappingURL=standalone.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/binaries/standalone_xml.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst semver = require(\"semver\");\nconst config_1 = require(\"../config\");\nconst config_source_1 = require(\"./config_source\");\nclass StandaloneXml extends config_source_1.XmlConfigSource {\n    constructor() {\n        super('standalone', config_1.Config.cdnUrls()['selenium']);\n    }\n    getUrl(version) {\n        if (version === 'latest') {\n            return this.getLatestStandaloneVersion();\n        }\n        else {\n            return this.getSpecificStandaloneVersion(version);\n        }\n    }\n    getVersionList() {\n        return this.getXml().then(xml => {\n            let versionPaths = [];\n            for (let content of xml.ListBucketResult.Contents) {\n                let contentKey = content.Key[0];\n                // Filter the selenium-server-standalone.\n                if (contentKey.includes('selenium-server-standalone')) {\n                    versionPaths.push(contentKey);\n                }\n            }\n            return versionPaths;\n        });\n    }\n    getLatestStandaloneVersion() {\n        return this.getVersionList().then(list => {\n            let standaloneVersion = null;\n            let latest = '';\n            let latestVersion = '';\n            for (let item of list) {\n                // Get a semantic version.\n                let version = item.split('selenium-server-standalone-')[1].replace('.jar', '');\n                // Do not do beta versions for latest.\n                if (!version.includes('beta')) {\n                    if (standaloneVersion == null) {\n                        // First time: use the version found.\n                        standaloneVersion = version;\n                        latest = item;\n                        latestVersion = version;\n                    }\n                    else if (semver.gt(version, standaloneVersion)) {\n                        // Get the latest.\n                        standaloneVersion = version;\n                        latest = item;\n                        latestVersion = version;\n                    }\n                }\n            }\n            return { url: config_1.Config.cdnUrls().selenium + latest, version: latestVersion };\n        });\n    }\n    getSpecificStandaloneVersion(inputVersion) {\n        return this.getVersionList().then(list => {\n            let itemFound = '';\n            let standaloneVersion = null;\n            for (let item of list) {\n                // Get a semantic version.\n                let version = item.split('selenium-server-standalone-')[1].replace('.jar', '');\n                // Check to see if the specified version matches.\n                let firstPath = item.split('/')[0];\n                if (version === inputVersion) {\n                    // Check if the beta exists that we have the right version\n                    // Example: We will see that beta3 appears in the file and path\n                    // 3.0-beta3/selenium-server-standalone-3.0.0-beta3.jar\n                    // where this should not work:\n                    // 3.0-beta2/selenium-server-standalone-3.0.0-beta3.jar\n                    if (inputVersion.includes('beta')) {\n                        let betaInputVersion = inputVersion.replace('.jar', '').split('beta')[1];\n                        if (item.split('/')[0].includes('beta' + betaInputVersion)) {\n                            return { url: config_1.Config.cdnUrls().selenium + item, version: version };\n                        }\n                    }\n                    else {\n                        return { url: config_1.Config.cdnUrls().selenium + item, version: version };\n                    }\n                }\n            }\n        });\n    }\n}\nexports.StandaloneXml = StandaloneXml;\n//# sourceMappingURL=standalone_xml.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/files/downloader.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst request = require(\"request\");\nconst url = require(\"url\");\nconst cli_1 = require(\"../cli\");\nconst http_utils_1 = require(\"../http_utils\");\nlet logger = new cli_1.Logger('downloader');\n/**\n * The file downloader.\n */\nclass Downloader {\n    /**\n     * Http get the file. Check the content length of the file before writing the file.\n     * If the content length does not match, remove it and download the file.\n     *\n     * @param binary The binary of interest.\n     * @param fileName The file name.\n     * @param outputDir The directory where files are downloaded and stored.\n     * @param contentLength The content length of the existing file.\n     * @param opt_proxy The proxy for downloading files.\n     * @param opt_ignoreSSL Should the downloader ignore SSL.\n     * @param opt_callback Callback method to be executed after the file is downloaded.\n     * @returns Promise<boolean> Resolves true = downloaded. Resolves false = not downloaded.\n     *          Rejected with an error.\n     */\n    static getFile(binary, fileUrl, fileName, outputDir, contentLength, opt_proxy, opt_ignoreSSL, callback) {\n        let filePath = path.resolve(outputDir, fileName);\n        let file;\n        let options = http_utils_1.HttpUtils.initOptions(fileUrl);\n        options = http_utils_1.HttpUtils.optionsSSL(options, opt_ignoreSSL);\n        options = http_utils_1.HttpUtils.optionsProxy(options, fileUrl, opt_proxy);\n        let req = null;\n        let resContentLength;\n        return new Promise((resolve, reject) => {\n            req = request(options);\n            req.on('response', response => {\n                if (response.statusCode === 200) {\n                    resContentLength = +response.headers['content-length'];\n                    if (contentLength === resContentLength) {\n                        // if the size is the same, do not download and stop here\n                        response.destroy();\n                        resolve(false);\n                    }\n                    else {\n                        if (opt_proxy) {\n                            let pathUrl = url.parse(options.url.toString()).path;\n                            let host = url.parse(options.url.toString()).host;\n                            let newFileUrl = url.resolve(opt_proxy, pathUrl);\n                            logger.info('curl -o ' + outputDir + '/' + fileName + ' \\'' + newFileUrl +\n                                '\\' -H \\'host:' + host + '\\'');\n                        }\n                        else {\n                            logger.info('curl -o ' + outputDir + '/' + fileName + ' ' + fileUrl);\n                        }\n                        // only pipe if the headers are different length\n                        file = fs.createWriteStream(filePath);\n                        req.pipe(file);\n                        file.on('close', () => {\n                            fs.stat(filePath, (error, stats) => {\n                                if (error) {\n                                    error.msg = 'Error: Got error ' + error + ' from ' + fileUrl;\n                                    return reject(error);\n                                }\n                                if (stats.size != resContentLength) {\n                                    error.msg = 'Error: corrupt download for ' + fileName +\n                                        '. Please re-run webdriver-manager update';\n                                    fs.unlinkSync(filePath);\n                                    reject(error);\n                                }\n                                if (callback) {\n                                    callback(binary, outputDir, fileName);\n                                }\n                                resolve(true);\n                            });\n                        });\n                    }\n                }\n                else {\n                    let error = new Error();\n                    error.msg =\n                        'Expected response code 200, received: ' + response.statusCode;\n                    reject(error);\n                }\n            });\n            req.on('error', error => {\n                if (error.code === 'ETIMEDOUT') {\n                    error.msg = 'Connection timeout downloading: ' + fileUrl +\n                        '. Default timeout is 4 minutes.';\n                }\n                else if (error.connect) {\n                    error.msg = 'Could not connect to the server to download: ' + fileUrl;\n                }\n                reject(error);\n            });\n        })\n            .catch(error => {\n            logger.error(error.msg);\n        });\n    }\n}\nexports.Downloader = Downloader;\n//# sourceMappingURL=downloader.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/files/file_manager.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst binaries_1 = require(\"../binaries\");\nconst cli_1 = require(\"../cli\");\nconst config_1 = require(\"../config\");\nconst downloaded_binary_1 = require(\"./downloaded_binary\");\nconst downloader_1 = require(\"./downloader\");\nlet logger = new cli_1.Logger('file_manager');\n/**\n * The File Manager class is where the webdriver manager will compile a list of\n * binaries that could be downloaded and get a list of previously downloaded\n * file versions.\n */\nclass FileManager {\n    /**\n     * Create a directory if it does not exist.\n     * @param outputDir The directory to create.\n     */\n    static makeOutputDirectory(outputDir) {\n        try {\n            fs.statSync(outputDir);\n        }\n        catch (e) {\n            logger.info('creating folder ' + outputDir);\n            fs.mkdirSync(outputDir);\n        }\n    }\n    /**\n     * For the operating system, check against the list of operating systems that the\n     * binary is available for.\n     * @param osType The operating system.\n     * @param binary The class type to have access to the static properties.\n     * @returns If the binary is available for the operating system.\n     */\n    static checkOS_(osType, binary) {\n        for (let os in binary.os) {\n            if (binaries_1.OS[os] == osType) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * For the operating system, create a list that includes the binaries\n     * for selenium standalone, chrome, and internet explorer.\n     * @param osType The operating system.\n     * @param alternateCDN URL of the alternative CDN to be used instead of the default ones.\n     * @returns A binary map that are available for the operating system.\n     */\n    static compileBinaries_(osType, alternateCDN) {\n        let binaries = {};\n        if (FileManager.checkOS_(osType, binaries_1.Standalone)) {\n            binaries[binaries_1.Standalone.id] = new binaries_1.Standalone(alternateCDN);\n        }\n        if (FileManager.checkOS_(osType, binaries_1.ChromeDriver)) {\n            binaries[binaries_1.ChromeDriver.id] = new binaries_1.ChromeDriver(alternateCDN);\n        }\n        if (FileManager.checkOS_(osType, binaries_1.GeckoDriver)) {\n            binaries[binaries_1.GeckoDriver.id] = new binaries_1.GeckoDriver(alternateCDN);\n        }\n        if (FileManager.checkOS_(osType, binaries_1.IEDriver)) {\n            binaries[binaries_1.IEDriver.id] = new binaries_1.IEDriver(alternateCDN);\n        }\n        if (FileManager.checkOS_(osType, binaries_1.AndroidSDK)) {\n            binaries[binaries_1.AndroidSDK.id] = new binaries_1.AndroidSDK(alternateCDN);\n        }\n        if (FileManager.checkOS_(osType, binaries_1.Appium)) {\n            binaries[binaries_1.Appium.id] = new binaries_1.Appium(alternateCDN);\n        }\n        return binaries;\n    }\n    /**\n     * Look up the operating system and compile a list of binaries that are available\n     * for the system.\n     * @param alternateCDN URL of the alternative CDN to be used instead of the default ones.\n     * @returns A binary map that is available for the operating system.\n     */\n    static setupBinaries(alternateCDN) {\n        return FileManager.compileBinaries_(config_1.Config.osType(), alternateCDN);\n    }\n    /**\n     * Get the list of existing files from the output directory\n     * @param outputDir The directory where binaries are saved\n     * @returns A list of existing files.\n     */\n    static getExistingFiles(outputDir) {\n        try {\n            return fs.readdirSync(outputDir);\n        }\n        catch (e) {\n            return [];\n        }\n    }\n    /**\n     * For the binary, operating system, and system architecture, look through\n     * the existing files and the downloaded binary\n     * @param binary The binary of interest\n     * @param osType The operating system.\n     * @param existingFiles A list of existing files.\n     * @returns The downloaded binary with all the versions found.\n     */\n    static downloadedVersions_(binary, osType, arch, existingFiles) {\n        let versions = [];\n        for (let existPos in existingFiles) {\n            let existFile = existingFiles[existPos];\n            // use only files that have a prefix and suffix that we care about\n            if (existFile.indexOf(binary.prefix()) === 0) {\n                let editExistFile = existFile.replace(binary.prefix(), '');\n                // if the suffix matches the executable suffix, add it\n                if (binary.suffix() === binary.executableSuffix()) {\n                    versions.push(editExistFile.replace(binary.suffix(), ''));\n                }\n                else if (!existFile.endsWith('.zip') && !existFile.endsWith('.tar.gz') &&\n                    existFile.indexOf(binary.suffix()) === -1) {\n                    editExistFile = editExistFile.replace(binary.executableSuffix(), '');\n                    editExistFile = editExistFile.indexOf('_') === 0 ?\n                        editExistFile.substring(1, editExistFile.length) :\n                        editExistFile;\n                    versions.push(editExistFile);\n                }\n            }\n        }\n        if (versions.length === 0) {\n            return null;\n        }\n        let downloadedBinary = new downloaded_binary_1.DownloadedBinary(binary);\n        downloadedBinary.versions = versions;\n        return downloadedBinary;\n    }\n    /**\n     * Finds all the downloaded binary versions stored in the output directory.\n     * @param outputDir The directory where files are downloaded and stored.\n     * @returns An dictionary map of all the downloaded binaries found in the output folder.\n     */\n    static downloadedBinaries(outputDir) {\n        let ostype = config_1.Config.osType();\n        let arch = config_1.Config.osArch();\n        let binaries = FileManager.setupBinaries();\n        let existingFiles = FileManager.getExistingFiles(outputDir);\n        let downloaded = {};\n        for (let bin in binaries) {\n            let binary = FileManager.downloadedVersions_(binaries[bin], ostype, arch, existingFiles);\n            if (binary != null) {\n                downloaded[binary.id()] = binary;\n            }\n        }\n        return downloaded;\n    }\n    /**\n     * Try to download the binary version.\n     * @param binary The binary of interest.\n     * @param outputDir The directory where files are downloaded and stored.\n     * @returns Promise resolved to true for files downloaded, resolved to false for files not\n     *          downloaded because they exist, rejected if there is an error.\n     */\n    static downloadFile(binary, outputDir, opt_proxy, opt_ignoreSSL, callback) {\n        return new Promise((resolve, reject) => {\n            let outDir = config_1.Config.getSeleniumDir();\n            let downloaded = FileManager.downloadedBinaries(outputDir);\n            let contentLength = 0;\n            // Pass options down to binary to make request to get the latest version to download.\n            binary.getUrl(binary.version(), opt_proxy, opt_ignoreSSL).then(fileUrl => {\n                binary.versionCustom = fileUrl.version;\n                let filePath = path.resolve(outputDir, binary.filename());\n                let fileName = binary.filename();\n                // If we have downloaded the file before, check the content length\n                if (downloaded[binary.id()]) {\n                    let downloadedBinary = downloaded[binary.id()];\n                    let versions = downloadedBinary.versions;\n                    let version = binary.versionCustom;\n                    for (let index in versions) {\n                        let v = versions[index];\n                        if (v === version) {\n                            contentLength = fs.statSync(filePath).size;\n                            downloader_1.Downloader\n                                .getFile(binary, fileUrl.url, fileName, outputDir, contentLength, opt_proxy, opt_ignoreSSL, callback)\n                                .then(downloaded => {\n                                resolve(downloaded);\n                            });\n                        }\n                    }\n                }\n                // We have not downloaded it before, or the version does not exist. Use the default content\n                // length of zero and download the file.\n                downloader_1.Downloader\n                    .getFile(binary, fileUrl.url, fileName, outputDir, contentLength, opt_proxy, opt_ignoreSSL, callback)\n                    .then(downloaded => {\n                    resolve(downloaded);\n                });\n            });\n        });\n    }\n    /**\n     * Removes the existing files found in the output directory that match the\n     * binary prefix names.\n     * @param outputDir The directory where files are downloaded and stored.\n     */\n    static removeExistingFiles(outputDir) {\n        try {\n            fs.statSync(outputDir);\n        }\n        catch (e) {\n            logger.warn('path does not exist ' + outputDir);\n            return;\n        }\n        let existingFiles = FileManager.getExistingFiles(outputDir);\n        if (existingFiles.length === 0) {\n            logger.warn('no files found in path ' + outputDir);\n            return;\n        }\n        let binaries = FileManager.setupBinaries();\n        existingFiles.forEach((file) => {\n            for (let binPos in binaries) {\n                let bin = binaries[binPos];\n                if (file.indexOf(bin.prefix()) !== -1) {\n                    bin.remove(path.resolve(outputDir, file));\n                    logger.info('removed ' + file);\n                }\n            }\n        });\n        let updateConfig = path.resolve(outputDir, 'update-config.json');\n        try {\n            fs.unlinkSync(updateConfig);\n            logger.info('removed update-config.json');\n        }\n        catch (e) {\n            return;\n        }\n    }\n}\nexports.FileManager = FileManager;\n//# sourceMappingURL=file_manager.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/cmds/index.js":"\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./opts\"));\n//# sourceMappingURL=index.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/cmds/opts.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst binaries_1 = require(\"../binaries\");\nconst cli_1 = require(\"../cli\");\nconst config_1 = require(\"../config\");\nexports.OUT_DIR = 'out_dir';\nexports.SELENIUM_PORT = 'seleniumPort';\nexports.APPIUM_PORT = 'appium-port';\nexports.AVD_PORT = 'avd-port';\nexports.IGNORE_SSL = 'ignore_ssl';\nexports.PROXY = 'proxy';\nexports.ALTERNATE_CDN = 'alternate_cdn';\nexports.STANDALONE = 'standalone';\nexports.CHROME = 'chrome';\nexports.IE = 'ie';\nexports.IE32 = 'ie32';\nexports.IE64 = 'ie64';\nexports.EDGE = 'edge';\nexports.GECKO = 'gecko';\nexports.ANDROID = 'android';\nexports.IOS = 'ios';\nexports.VERSIONS_CHROME = 'versions.chrome';\nexports.VERSIONS_GECKO = 'versions.gecko';\nexports.VERSIONS_STANDALONE = 'versions.standalone';\nexports.VERSIONS_IE = 'versions.ie';\nexports.VERSIONS_ANDROID = 'versions.android';\nexports.VERSIONS_APPIUM = 'versions.appium';\nexports.CHROME_LOGS = 'chrome_logs';\nexports.LOGGING = 'logging';\nexports.ANDROID_API_LEVELS = 'android-api-levels';\nexports.ANDROID_ARCHITECTURES = 'android-archs';\nexports.ANDROID_PLATFORMS = 'android-platorms';\nexports.ANDROID_ACCEPT_LICENSES = 'android-accept-licenses';\nexports.AVDS = 'avds';\nexports.AVD_USE_SNAPSHOTS = 'avd-use-snapshots';\nexports.STARTED_SIGNIFIER = 'started-signifier';\nexports.SIGNAL_VIA_IPC = 'signal-via-ipc';\nexports.DETACH = 'detach';\nexports.QUIET = 'quiet';\nexports.VERBOSE = 'verbose';\nexports.ALREADY_OFF_ERROR = 'already-off-error';\n/**\n * The options used by the commands.\n */\nvar opts = {};\nopts[exports.OUT_DIR] = new cli_1.Option(exports.OUT_DIR, 'Location to output/expect', 'string', config_1.Config.getSeleniumDir());\nopts[exports.SELENIUM_PORT] =\n    new cli_1.Option(exports.SELENIUM_PORT, 'Optional port for the selenium standalone server', 'string', '4444');\nopts[exports.APPIUM_PORT] =\n    new cli_1.Option(exports.APPIUM_PORT, 'Optional port for the appium server', 'string', '4723');\nopts[exports.AVD_PORT] = new cli_1.Option(exports.AVD_PORT, 'Optional port for android virtual devices.  See mobile.md for details', 'number', 5554);\nopts[exports.IGNORE_SSL] = new cli_1.Option(exports.IGNORE_SSL, 'Ignore SSL certificates', 'boolean', false);\nopts[exports.PROXY] = new cli_1.Option(exports.PROXY, 'Proxy to use for the install or update command', 'string');\nopts[exports.ALTERNATE_CDN] = new cli_1.Option(exports.ALTERNATE_CDN, 'Alternate CDN to binaries', 'string');\nopts[exports.STANDALONE] = new cli_1.Option(exports.STANDALONE, 'Install or update selenium standalone', 'boolean', binaries_1.Standalone.isDefault);\nopts[exports.CHROME] =\n    new cli_1.Option(exports.CHROME, 'Install or update chromedriver', 'boolean', binaries_1.ChromeDriver.isDefault);\nopts[exports.GECKO] = new cli_1.Option(exports.GECKO, 'Install or update geckodriver', 'boolean', binaries_1.GeckoDriver.isDefault);\nopts[exports.IE] = new cli_1.Option(exports.IE, 'Install or update 32-bit ie driver', 'boolean', binaries_1.IEDriver.isDefault32);\nopts[exports.IE32] =\n    new cli_1.Option(exports.IE32, 'Install or update 32-bit ie driver', 'boolean', binaries_1.IEDriver.isDefault32);\nopts[exports.IE64] = new cli_1.Option(exports.IE64, 'Update: install or update 64-bit IE driver. Start: use installed x64 IE driver.', 'boolean', binaries_1.IEDriver.isDefault64);\nopts[exports.EDGE] = new cli_1.Option(exports.EDGE, 'Use installed Microsoft Edge driver', 'string', 'C:\\\\Program Files (x86)\\\\Microsoft Web Driver\\\\MicrosoftWebDriver.exe');\nopts[exports.ANDROID] = new cli_1.Option(exports.ANDROID, 'Update/use the android sdk', 'boolean', binaries_1.AndroidSDK.isDefault);\nopts[exports.IOS] = new cli_1.Option(exports.IOS, 'Update the iOS sdk', 'boolean', false);\nopts[exports.VERSIONS_CHROME] = new cli_1.Option(exports.VERSIONS_CHROME, 'Optional chrome driver version (use \\'latest\\' to get the most recent version)', 'string', 'latest');\nopts[exports.VERSIONS_GECKO] =\n    new cli_1.Option(exports.VERSIONS_GECKO, 'Optional gecko driver version', 'string', 'latest');\nopts[exports.VERSIONS_ANDROID] = new cli_1.Option(exports.VERSIONS_ANDROID, 'Optional android sdk version', 'string', binaries_1.AndroidSDK.versionDefault);\nopts[exports.VERSIONS_STANDALONE] = new cli_1.Option(exports.VERSIONS_STANDALONE, 'Optional seleniuim standalone server version (use \\'latest\\' to get the most recent version)', 'string', 'latest');\nopts[exports.VERSIONS_APPIUM] =\n    new cli_1.Option(exports.VERSIONS_APPIUM, 'Optional appium version', 'string', binaries_1.Appium.versionDefault);\nopts[exports.VERSIONS_IE] = new cli_1.Option(exports.VERSIONS_IE, 'Optional internet explorer driver version (use \\'latest\\' to get the most recent version)', 'string', 'latest');\nopts[exports.CHROME_LOGS] = new cli_1.Option(exports.CHROME_LOGS, 'File path to chrome logs', 'string', undefined);\nopts[exports.LOGGING] = new cli_1.Option(exports.LOGGING, 'File path to logging properties file', 'string', undefined);\nopts[exports.ANDROID_API_LEVELS] = new cli_1.Option(exports.ANDROID_API_LEVELS, 'Which versions of the android API you want to emulate', 'string', binaries_1.AndroidSDK.DEFAULT_API_LEVELS);\nopts[exports.ANDROID_ARCHITECTURES] = new cli_1.Option(exports.ANDROID_ARCHITECTURES, 'Which architectures you want to use in android emulation.  By default it will try to match os.arch()', 'string', binaries_1.AndroidSDK.DEFAULT_ARCHITECTURES);\nopts[exports.ANDROID_PLATFORMS] = new cli_1.Option(exports.ANDROID_PLATFORMS, 'Which platforms you want to use in android emulation', 'string', binaries_1.AndroidSDK.DEFAULT_PLATFORMS);\nopts[exports.ANDROID_ACCEPT_LICENSES] =\n    new cli_1.Option(exports.ANDROID_ACCEPT_LICENSES, 'Automatically accept android licenses', 'boolean', false);\nopts[exports.AVDS] = new cli_1.Option(exports.AVDS, 'Android virtual devices to emulate.  Use \"all\" for emulating all possible devices, and \"none\" for no devices', 'string', 'all');\nopts[exports.AVD_USE_SNAPSHOTS] = new cli_1.Option(exports.AVD_USE_SNAPSHOTS, 'Rather than booting a new AVD every time, save/load snapshots of the last time it was used', 'boolean', true);\nopts[exports.STARTED_SIGNIFIER] = new cli_1.Option(exports.STARTED_SIGNIFIER, 'A string to be outputted once the selenium server is up and running.  Useful if you are writing a script which uses webdriver-manager.', 'string');\nopts[exports.SIGNAL_VIA_IPC] = new cli_1.Option(exports.SIGNAL_VIA_IPC, 'If you are using --' + exports.STARTED_SIGNIFIER +\n    ', this flag will emit the signal string using process.send(), rather than writing it to stdout', 'boolean', false);\nopts[exports.DETACH] = new cli_1.Option(exports.DETACH, 'Once the selenium server is up and running, return control to the parent process and continue running the server in the background.', 'boolean', false);\nopts[exports.VERBOSE] = new cli_1.Option(exports.VERBOSE, 'Extra console output', 'boolean', false);\nopts[exports.QUIET] = new cli_1.Option(exports.QUIET, 'Minimal console output', 'boolean', false);\nopts[exports.ALREADY_OFF_ERROR] = new cli_1.Option(exports.ALREADY_OFF_ERROR, 'Normally if you try to shut down a selenium which is not running, you will get a warning.  This turns it into an error', 'boolean', false);\nexports.Opts = opts;\n//# sourceMappingURL=opts.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/cmds/shutdown.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http = require(\"http\");\nconst minimist = require(\"minimist\");\nconst cli_1 = require(\"../cli\");\nconst Opt = require(\"./\");\nconst opts_1 = require(\"./opts\");\nlet logger = new cli_1.Logger('shutdown');\nlet prog = new cli_1.Program()\n    .command('shutdown', 'shut down the selenium server')\n    .action(shutdown)\n    .addOption(opts_1.Opts[Opt.SELENIUM_PORT])\n    .addOption(opts_1.Opts[Opt.ALREADY_OFF_ERROR]);\nexports.program = prog;\n// stand alone runner\nlet argv = minimist(process.argv.slice(2), prog.getMinimistOptions());\nif (argv._[0] === 'shutdown-run') {\n    prog.run(JSON.parse(JSON.stringify(argv)));\n}\nelse if (argv._[0] === 'shutdown-help') {\n    prog.printHelp();\n}\n/**\n * Parses the options and starts the selenium standalone server.\n * @param options\n */\nfunction shutdown(options) {\n    logger.info('Attempting to shut down selenium nicely');\n    http.get('http://localhost:' + options[Opt.SELENIUM_PORT].getString() +\n        '/selenium-server/driver/?cmd=shutDownSeleniumServer')\n        .on('error', (e) => {\n        if ((e.code == 'ECONNREFUSED') && (e.syscall == 'connect')) {\n            if (!options[Opt.ALREADY_OFF_ERROR].getBoolean()) {\n                logger.warn('Server does not appear to be on');\n            }\n            else {\n                logger.error('Server unreachable, probably not running');\n                throw e;\n            }\n        }\n        else {\n            throw e;\n        }\n    });\n}\n//# sourceMappingURL=shutdown.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/cmds/start.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst http = require(\"http\");\nconst minimist = require(\"minimist\");\nconst path = require(\"path\");\nconst binaries_1 = require(\"../binaries\");\nconst cli_1 = require(\"../cli\");\nconst config_1 = require(\"../config\");\nconst files_1 = require(\"../files\");\nconst utils_1 = require(\"../utils\");\nconst Opt = require(\"./\");\nconst opts_1 = require(\"./opts\");\nconst commandName = 'start';\nlet logger = new cli_1.Logger('start');\nlet prog = new cli_1.Program()\n    .command(commandName, 'start up the selenium server')\n    .action(start)\n    .addOption(opts_1.Opts[Opt.OUT_DIR])\n    .addOption(opts_1.Opts[Opt.SELENIUM_PORT])\n    .addOption(opts_1.Opts[Opt.APPIUM_PORT])\n    .addOption(opts_1.Opts[Opt.AVD_PORT])\n    .addOption(opts_1.Opts[Opt.VERSIONS_STANDALONE])\n    .addOption(opts_1.Opts[Opt.VERSIONS_CHROME])\n    .addOption(opts_1.Opts[Opt.VERSIONS_GECKO])\n    .addOption(opts_1.Opts[Opt.VERSIONS_ANDROID])\n    .addOption(opts_1.Opts[Opt.VERSIONS_APPIUM])\n    .addOption(opts_1.Opts[Opt.CHROME_LOGS])\n    .addOption(opts_1.Opts[Opt.LOGGING])\n    .addOption(opts_1.Opts[Opt.ANDROID])\n    .addOption(opts_1.Opts[Opt.AVDS])\n    .addOption(opts_1.Opts[Opt.AVD_USE_SNAPSHOTS])\n    .addOption(opts_1.Opts[Opt.STARTED_SIGNIFIER])\n    .addOption(opts_1.Opts[Opt.SIGNAL_VIA_IPC])\n    .addOption(opts_1.Opts[Opt.QUIET])\n    .addOption(opts_1.Opts[Opt.DETACH]);\nif (config_1.Config.osType() === 'Darwin') {\n    prog.addOption(opts_1.Opts[Opt.IOS]);\n}\nif (config_1.Config.osType() === 'Windows_NT') {\n    prog.addOption(opts_1.Opts[Opt.VERSIONS_IE]).addOption(opts_1.Opts[Opt.IE64]).addOption(opts_1.Opts[Opt.EDGE]);\n}\nexports.program = prog;\n// stand alone runner\nlet argv = minimist(process.argv.slice(2), prog.getMinimistOptions());\nif (argv._[0] === 'start-run') {\n    prog.run(JSON.parse(JSON.stringify(argv)));\n}\nelse if (argv._[0] === 'start-help') {\n    prog.printHelp();\n}\n// Manage processes used in android emulation\nlet androidProcesses = [];\nlet androidActiveAVDs = [];\n/**\n * Parses the options and starts the selenium standalone server.\n * @param options\n */\nfunction start(options) {\n    if (options[Opt.DETACH].getBoolean()) {\n        return detachedRun(options);\n    }\n    let osType = config_1.Config.osType();\n    let stdio = options[Opt.QUIET].getBoolean() ? 'pipe' : 'inherit';\n    let binaries = files_1.FileManager.setupBinaries();\n    let seleniumPort = options[Opt.SELENIUM_PORT].getString();\n    let appiumPort = options[Opt.APPIUM_PORT].getString();\n    let avdPort = options[Opt.AVD_PORT].getNumber();\n    let android = options[Opt.ANDROID].getBoolean();\n    let outputDir = config_1.Config.getSeleniumDir();\n    if (options[Opt.OUT_DIR].getString()) {\n        if (path.isAbsolute(options[Opt.OUT_DIR].getString())) {\n            outputDir = options[Opt.OUT_DIR].getString();\n        }\n        else {\n            outputDir = path.resolve(config_1.Config.getBaseDir(), options[Opt.OUT_DIR].getString());\n        }\n    }\n    try {\n        // check if folder exists\n        fs.statSync(outputDir).isDirectory();\n    }\n    catch (e) {\n        // if the folder does not exist, quit early.\n        logger.warn('the out_dir path ' + outputDir + ' does not exist, run webdriver-manager update');\n        return;\n    }\n    let chromeLogs = null;\n    let loggingFile = null;\n    if (options[Opt.CHROME_LOGS].getString()) {\n        if (path.isAbsolute(options[Opt.CHROME_LOGS].getString())) {\n            chromeLogs = options[Opt.CHROME_LOGS].getString();\n        }\n        else {\n            chromeLogs = path.resolve(config_1.Config.getBaseDir(), options[Opt.CHROME_LOGS].getString());\n        }\n    }\n    binaries[binaries_1.Standalone.id].versionCustom = options[Opt.VERSIONS_STANDALONE].getString();\n    binaries[binaries_1.ChromeDriver.id].versionCustom = options[Opt.VERSIONS_CHROME].getString();\n    binaries[binaries_1.GeckoDriver.id].versionCustom = options[Opt.VERSIONS_GECKO].getString();\n    if (options[Opt.VERSIONS_IE]) {\n        binaries[binaries_1.IEDriver.id].versionCustom = options[Opt.VERSIONS_IE].getString();\n    }\n    binaries[binaries_1.AndroidSDK.id].versionCustom = options[Opt.VERSIONS_ANDROID].getString();\n    binaries[binaries_1.Appium.id].versionCustom = options[Opt.VERSIONS_APPIUM].getString();\n    let downloadedBinaries = files_1.FileManager.downloadedBinaries(outputDir);\n    if (downloadedBinaries[binaries_1.Standalone.id] == null) {\n        logger.error('Selenium Standalone is not present. Install with ' +\n            'webdriver-manager update --standalone');\n        process.exit(1);\n    }\n    let promises = [];\n    let args = [];\n    if (osType === 'Linux') {\n        // selenium server may take a long time to start because /dev/random is BLOCKING if there is not\n        // enough entropy the solution is to use /dev/urandom, which is NON-BLOCKING (use /dev/./urandom\n        // because of a java bug)\n        // https://github.com/seleniumhq/selenium-google-code-issue-archive/issues/1301\n        // https://bugs.openjdk.java.net/browse/JDK-6202721\n        promises.push(Promise.resolve(args.push('-Djava.security.egd=file:///dev/./urandom')));\n    }\n    if (options[Opt.LOGGING].getString()) {\n        if (path.isAbsolute(options[Opt.LOGGING].getString())) {\n            loggingFile = options[Opt.LOGGING].getString();\n        }\n        else {\n            loggingFile = path.resolve(config_1.Config.getBaseDir(), options[Opt.LOGGING].getString());\n        }\n        promises.push(Promise.resolve(args.push('-Djava.util.logging.config.file=' + loggingFile)));\n    }\n    if (downloadedBinaries[binaries_1.ChromeDriver.id] != null) {\n        let chrome = binaries[binaries_1.ChromeDriver.id];\n        promises.push(chrome.getUrl(chrome.versionCustom)\n            .then(() => {\n            args.push('-Dwebdriver.chrome.driver=' +\n                path.resolve(outputDir, binaries[binaries_1.ChromeDriver.id].executableFilename()));\n            if (chromeLogs != null) {\n                args.push('-Dwebdriver.chrome.logfile=' + chromeLogs);\n            }\n        })\n            .catch(err => {\n            console.log(err);\n        }));\n    }\n    if (downloadedBinaries[binaries_1.GeckoDriver.id] != null) {\n        let gecko = binaries[binaries_1.GeckoDriver.id];\n        promises.push(gecko.getUrl(gecko.versionCustom)\n            .then(() => {\n            args.push('-Dwebdriver.gecko.driver=' +\n                path.resolve(outputDir, binaries[binaries_1.GeckoDriver.id].executableFilename()));\n        })\n            .catch(err => {\n            console.log(err);\n        }));\n    }\n    if (downloadedBinaries[binaries_1.IEDriver.id] != null) {\n        let ie = binaries[binaries_1.IEDriver.id];\n        promises.push(ie.getUrl(ie.versionCustom)\n            .then(() => {\n            binaries[binaries_1.IEDriver.id].osarch = 'Win32'; // use Win 32 by default\n            if (options[Opt.IE64].getBoolean()) {\n                binaries[binaries_1.IEDriver.id].osarch =\n                    config_1.Config.osArch(); // use the system architecture\n            }\n            args.push('-Dwebdriver.ie.driver=' +\n                path.resolve(outputDir, binaries[binaries_1.IEDriver.id].executableFilename()));\n        })\n            .catch(err => {\n            console.log(err);\n        }));\n    }\n    if (options[Opt.EDGE] && options[Opt.EDGE].getString()) {\n        // validate that the file exists prior to adding it to args\n        try {\n            let edgeFile = options[Opt.EDGE].getString();\n            if (fs.statSync(edgeFile).isFile()) {\n                promises.push(Promise.resolve(args.push('-Dwebdriver.edge.driver=' + options[Opt.EDGE].getString())));\n            }\n        }\n        catch (err) {\n            // Either the default file or user specified location of the edge\n            // driver does not exist.\n        }\n    }\n    Promise.all(promises).then(() => {\n        let standalone = binaries[binaries_1.Standalone.id];\n        standalone.getUrl(standalone.versionCustom)\n            .then(() => {\n            // starting android\n            if (android) {\n                if (downloadedBinaries[binaries_1.AndroidSDK.id] != null) {\n                    let avds = options[Opt.AVDS].getString();\n                    startAndroid(outputDir, binaries[binaries_1.AndroidSDK.id], avds.split(','), options[Opt.AVD_USE_SNAPSHOTS].getBoolean(), avdPort, stdio);\n                }\n                else {\n                    logger.warn('Not starting android because it is not installed');\n                }\n            }\n            if (downloadedBinaries[binaries_1.Appium.id] != null) {\n                startAppium(outputDir, binaries[binaries_1.Appium.id], binaries[binaries_1.AndroidSDK.id], appiumPort, stdio);\n            }\n            args.push('-jar');\n            args.push(path.resolve(outputDir, binaries[binaries_1.Standalone.id].filename()));\n        })\n            .catch(err => {\n            console.log(err);\n        })\n            .then(() => {\n            // Add the port parameter, has to declared after the jar file\n            if (seleniumPort) {\n                args.push('-port', seleniumPort);\n            }\n            let argsToString = '';\n            for (let arg in args) {\n                argsToString += ' ' + args[arg];\n            }\n            logger.info('java' + argsToString);\n            let seleniumProcess = utils_1.spawn('java', args, stdio);\n            if (options[Opt.STARTED_SIGNIFIER].getString()) {\n                signalWhenReady(options[Opt.STARTED_SIGNIFIER].getString(), options[Opt.SIGNAL_VIA_IPC].getBoolean(), outputDir, seleniumPort, downloadedBinaries[binaries_1.Appium.id] ? appiumPort : '', binaries[binaries_1.AndroidSDK.id], avdPort, androidActiveAVDs);\n            }\n            logger.info('seleniumProcess.pid: ' + seleniumProcess.pid);\n            seleniumProcess.on('exit', (code) => {\n                logger.info('Selenium Standalone has exited with code ' + code);\n                shutdownEverything();\n                process.exit(process.exitCode || code);\n            });\n            seleniumProcess.on('error', (error) => {\n                logger.warn('Selenium Standalone server encountered an error: ' + error);\n            });\n            process.stdin.resume();\n            process.stdin.on('data', (chunk) => {\n                logger.info('Attempting to shut down selenium nicely');\n                shutdownEverything(seleniumPort);\n            });\n            process.on('SIGINT', () => {\n                logger.info('Staying alive until the Selenium Standalone process exits');\n                shutdownEverything(seleniumPort);\n            });\n        });\n    });\n}\nfunction startAndroid(outputDir, sdk, avds, useSnapshots, port, stdio) {\n    let sdkPath = path.resolve(outputDir, sdk.executableFilename());\n    if (avds[0] == 'all') {\n        avds = require(path.resolve(sdkPath, 'available_avds.json'));\n    }\n    else if (avds[0] == 'none') {\n        avds.length = 0;\n    }\n    const minAVDPort = 5554;\n    const maxAVDPort = 5586 - 2 * avds.length;\n    if (avds.length && ((port < minAVDPort) || (port > maxAVDPort))) {\n        throw new RangeError('AVD Port must be between ' + minAVDPort + ' and ' + maxAVDPort + ' to emulate ' +\n            avds.length + ' android devices');\n    }\n    avds.forEach((avd, i) => {\n        // Credit to appium-ci, which this code was adapted from\n        let emuBin = 'emulator'; // TODO(sjelin): get the 64bit linux version working\n        let emuArgs = [\n            '-avd',\n            avd + '-v' + sdk.versionCustom + '-wd-manager',\n            '-netfast',\n        ];\n        let portArg = null;\n        if (!useSnapshots) {\n            emuArgs = emuArgs.concat(['-no-snapshot-load', '-no-snapshot-save']);\n        }\n        if (port) {\n            portArg = port + i * 2;\n            emuArgs = emuArgs.concat(['-port', '' + portArg]);\n        }\n        if (emuBin !== 'emulator') {\n            emuArgs = emuArgs.concat(['-qemu', '-enable-kvm']);\n        }\n        logger.info('Starting ' + avd + ' on ' + (portArg == null ? 'default port' : 'port ' + portArg));\n        let child = utils_1.spawn(path.resolve(sdkPath, 'tools', emuBin), emuArgs, stdio);\n        child.on('error', (error) => {\n            logger.warn(avd + ' encountered an error: ' + error);\n        });\n        androidProcesses.push(child);\n        androidActiveAVDs.push(avd);\n    });\n}\nfunction killAndroid() {\n    for (var i = 0; i < androidProcesses.length; i++) {\n        logger.info('Shutting down ' + androidActiveAVDs[i]);\n        androidProcesses[i].kill();\n    }\n    androidProcesses.length = androidActiveAVDs.length = 0;\n}\n// Manage appium process\nlet appiumProcess;\nfunction startAppium(outputDir, binary, androidSDK, port, stdio) {\n    logger.info('Starting appium server');\n    if (androidSDK) {\n        process.env.ANDROID_HOME = path.resolve(outputDir, androidSDK.executableFilename());\n    }\n    appiumProcess = utils_1.spawn('npm', ['run', 'appium'].concat(port ? ['--', '--port', port] : []), stdio, { cwd: path.resolve(outputDir, binary.filename()) });\n}\nfunction killAppium() {\n    if (appiumProcess != null) {\n        appiumProcess.kill();\n        appiumProcess = null;\n    }\n}\nfunction signalWhenReady(signal, viaIPC, outputDir, seleniumPort, appiumPort, androidSDK, avdPort, avdNames) {\n    const maxWait = 10 * 60 * 1000; // Ten minutes\n    function waitFor(getStatus, testStatus, desc) {\n        const checkInterval = 100;\n        return new Promise((resolve, reject) => {\n            let waited = 0;\n            (function recursiveCheck() {\n                setTimeout(() => {\n                    getStatus()\n                        .then((status) => {\n                        if (!testStatus(status)) {\n                            return Promise.reject('Invalid status' + (desc ? ' for ' + desc : '') + ': ' + status);\n                        }\n                    })\n                        .then(() => {\n                        resolve();\n                    }, (error) => {\n                        waited += checkInterval;\n                        if (waited < maxWait) {\n                            recursiveCheck();\n                        }\n                        else {\n                            reject('Timed out' + (desc ? ' wating for' + desc : '') +\n                                '.  Final rejection reason: ' + JSON.stringify(error));\n                        }\n                    });\n                }, checkInterval);\n            })();\n        });\n    }\n    ;\n    function waitForAndroid(avdPort, avdName, appiumPort) {\n        let sdkPath = path.resolve(outputDir, androidSDK.executableFilename());\n        logger.info('Waiting for ' + avdName + '\\'s emulator to start');\n        return utils_1.adb(sdkPath, avdPort, 'wait-for-device', maxWait)\n            .then(() => {\n            logger.info('Waiting for ' + avdName + '\\'s OS to boot up');\n            return waitFor(() => {\n                return utils_1.adb(sdkPath, avdPort, 'shell', maxWait, ['getprop', 'sys.boot_completed']);\n            }, (status) => {\n                return status.trim() == '1';\n            }, avdName + '\\'s OS');\n        }, (error) => {\n            return Promise.reject('Failed to wait for ' + avdName + '\\'s emulator to start (' + error.code + ': ' +\n                error.message + ')');\n        })\n            .then(() => {\n            logger.info('Waiting for ' + avdName + ' to be ready to launch chrome');\n            let version = binaries_1.AndroidSDK.VERSIONS[parseInt(avdName.slice('android-'.length))];\n            return utils_1.request('POST', appiumPort, '/wd/hub/session', maxWait, {\n                desiredCapabilities: {\n                    browserName: 'chrome',\n                    platformName: 'Android',\n                    platformVersion: version,\n                    deviceName: 'Android Emulator'\n                }\n            })\n                .then((data) => {\n                return JSON.parse(data)['sessionId'];\n            }, (error) => {\n                return Promise.reject('Could not start chrome on ' + avdName + ' (' + error.code + ': ' +\n                    error.message + ')');\n            });\n        })\n            .then((sessionId) => {\n            logger.info('Shutting down dummy chrome instance for ' + avdName);\n            return utils_1.request('DELETE', appiumPort, '/wd/hub/session/' + sessionId)\n                .then(() => { }, (error) => {\n                return Promise.reject('Could not close chrome on ' + avdName + ' (' + error.code + ': ' +\n                    error.message + ')');\n            });\n        });\n    }\n    let pending = [waitFor(() => {\n            return utils_1.request('GET', appiumPort, '/wd/hub/status', maxWait);\n        }, (status) => {\n            return JSON.parse(status).status == 0;\n        }, 'selenium server')];\n    if (appiumPort) {\n        pending.push(waitFor(() => {\n            return utils_1.request('GET', appiumPort, '/wd/hub/status', maxWait);\n        }, (status) => {\n            return JSON.parse(status).status == 0;\n        }, 'appium server'));\n    }\n    if (androidSDK && avdPort) {\n        for (let i = 0; i < avdNames.length; i++) {\n            pending.push(waitForAndroid(avdPort + 2 * i, avdNames[i], appiumPort));\n        }\n    }\n    Promise.all(pending).then(() => {\n        logger.info('Everything started');\n        sendStartedSignal(signal, viaIPC);\n    }, (error) => {\n        logger.error(error);\n        shutdownEverything(seleniumPort);\n        process.exitCode = 1;\n    });\n}\nfunction sendStartedSignal(signal, viaIPC) {\n    if (viaIPC) {\n        if (process.send) {\n            return process.send(signal);\n        }\n        else {\n            logger.warn('No IPC channel, sending signal via stdout');\n        }\n    }\n    console.log(signal);\n}\nfunction shutdownEverything(seleniumPort) {\n    if (seleniumPort) {\n        http.get('http://localhost:' + seleniumPort + '/selenium-server/driver/?cmd=shutDownSeleniumServer');\n    }\n    killAndroid();\n    killAppium();\n}\nfunction detachedRun(options) {\n    var file = path.resolve(__dirname, '..', 'webdriver.js');\n    var oldSignal = options[Opt.STARTED_SIGNIFIER].getString();\n    var oldViaIPC = options[Opt.SIGNAL_VIA_IPC].getBoolean();\n    options[Opt.DETACH].value = false;\n    options[Opt.STARTED_SIGNIFIER].value = 'server started';\n    options[Opt.SIGNAL_VIA_IPC].value = true;\n    let args = [file, commandName].concat(cli_1.unparseOptions(options));\n    var unreffed = false;\n    let child = utils_1.spawn(process.execPath, args, ['ignore', 1, 2, 'ipc']);\n    child.on('message', (message) => {\n        if (message == options[Opt.STARTED_SIGNIFIER].getString()) {\n            if (oldSignal) {\n                sendStartedSignal(oldSignal, oldViaIPC);\n            }\n            logger.info('Detached pid: ' + child.pid);\n            child.disconnect();\n            child.unref();\n            unreffed = true;\n        }\n    });\n    child.on('exit', (code) => {\n        if (!unreffed) {\n            if (code == 0) {\n                logger.warn('Server never seemed to start, and has now exited');\n            }\n            else {\n                logger.error('Server never seemed to start, and has probably crashed');\n            }\n            process.exit(code);\n        }\n    });\n}\n//# sourceMappingURL=start.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/cmds/status.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst minimist = require(\"minimist\");\nconst path = require(\"path\");\nconst semver = require(\"semver\");\nconst binaries_1 = require(\"../binaries\");\nconst cli_1 = require(\"../cli\");\nconst config_1 = require(\"../config\");\nconst files_1 = require(\"../files\");\nconst Opt = require(\"./\");\nconst opts_1 = require(\"./opts\");\nlet logger = new cli_1.Logger('status');\nlet prog = new cli_1.Program()\n    .command('status', 'list the current available drivers')\n    .addOption(opts_1.Opts[Opt.OUT_DIR])\n    .action(status);\nexports.program = prog;\n// stand alone runner\nlet argv = minimist(process.argv.slice(2), prog.getMinimistOptions());\nif (argv._[0] === 'status-run') {\n    prog.run(JSON.parse(JSON.stringify(argv)));\n}\nelse if (argv._[0] === 'status-help') {\n    prog.printHelp();\n}\n/**\n * Parses the options and logs the status of the binaries downloaded.\n * @param options\n */\nfunction status(options) {\n    let binaries = files_1.FileManager.setupBinaries();\n    let outputDir = config_1.Config.getSeleniumDir();\n    if (options[Opt.OUT_DIR].value) {\n        if (path.isAbsolute(options[Opt.OUT_DIR].getString())) {\n            outputDir = options[Opt.OUT_DIR].getString();\n        }\n        else {\n            outputDir = path.resolve(config_1.Config.getBaseDir(), options[Opt.OUT_DIR].getString());\n        }\n    }\n    try {\n        // check if folder exists\n        fs.statSync(outputDir).isDirectory();\n    }\n    catch (e) {\n        // if the folder does not exist, quit early.\n        logger.warn('the out_dir path ' + outputDir + ' does not exist');\n        return;\n    }\n    // Try to get the update-config.json. This will be used for showing the last binary downloaded.\n    let updateConfig = {};\n    try {\n        updateConfig =\n            JSON.parse(fs.readFileSync(path.resolve(outputDir, 'update-config.json')).toString()) || {};\n    }\n    catch (err) {\n        updateConfig = {};\n    }\n    let downloadedBinaries = files_1.FileManager.downloadedBinaries(outputDir);\n    // Log which binaries have been downloaded.\n    for (let bin in downloadedBinaries) {\n        let downloaded = downloadedBinaries[bin];\n        let log = downloaded.name + ' ';\n        log += downloaded.versions.length == 1 ? 'version available: ' : 'versions available: ';\n        // Get the \"last\" downloaded binary from the updateConfig.\n        let last = null;\n        if (downloaded.binary instanceof binaries_1.Appium && updateConfig[binaries_1.Appium.id]) {\n            last = updateConfig[binaries_1.Appium.id]['last'];\n        }\n        else if (downloaded.binary instanceof binaries_1.AndroidSDK && updateConfig[binaries_1.AndroidSDK.id]) {\n            last = updateConfig[binaries_1.AndroidSDK.id]['last'];\n        }\n        else if (downloaded.binary instanceof binaries_1.ChromeDriver && updateConfig[binaries_1.ChromeDriver.id]) {\n            last = updateConfig[binaries_1.ChromeDriver.id]['last'];\n        }\n        else if (downloaded.binary instanceof binaries_1.GeckoDriver && updateConfig[binaries_1.GeckoDriver.id]) {\n            last = updateConfig[binaries_1.GeckoDriver.id]['last'];\n        }\n        else if (downloaded.binary instanceof binaries_1.IEDriver && updateConfig[binaries_1.IEDriver.id]) {\n            last = updateConfig[binaries_1.IEDriver.id]['last'];\n        }\n        else if (downloaded.binary instanceof binaries_1.Standalone && updateConfig[binaries_1.Standalone.id]) {\n            last = updateConfig[binaries_1.Standalone.id]['last'];\n        }\n        // Sort the versions then log them:\n        // - last: the last binary downloaded by webdriver-manager per the update-config.json\n        downloaded.versions = downloaded.versions.sort((a, b) => {\n            if (!semver.valid(a)) {\n                a += '.0';\n                b += '.0';\n            }\n            if (semver.gt(a, b)) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        });\n        for (let ver in downloaded.versions) {\n            let version = downloaded.versions[ver];\n            log += version;\n            if (last && last.indexOf(version) >= 0) {\n                log += ' [last]';\n            }\n            if (+ver != downloaded.versions.length - 1) {\n                log += ', ';\n            }\n        }\n        logger.info(log);\n    }\n    // for binaries that are available for the operating system, show them here\n    for (let bin in binaries) {\n        if (downloadedBinaries[bin] == null) {\n            logger.info(binaries[bin].name + ' is not present');\n        }\n    }\n}\n//# sourceMappingURL=status.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/cmds/update.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst AdmZip = require(\"adm-zip\");\nconst child_process = require(\"child_process\");\nconst fs = require(\"fs\");\nconst minimist = require(\"minimist\");\nconst path = require(\"path\");\nconst q = require(\"q\");\nconst rimraf = require(\"rimraf\");\nconst binaries_1 = require(\"../binaries\");\nconst cli_1 = require(\"../cli\");\nconst config_1 = require(\"../config\");\nconst files_1 = require(\"../files\");\nconst utils_1 = require(\"../utils\");\nconst Opt = require(\"./\");\nconst initialize_1 = require(\"./initialize\");\nconst opts_1 = require(\"./opts\");\nlet logger = new cli_1.Logger('update');\nlet prog = new cli_1.Program()\n    .command('update', 'install or update selected binaries')\n    .action(update)\n    .addOption(opts_1.Opts[Opt.OUT_DIR])\n    .addOption(opts_1.Opts[Opt.VERBOSE])\n    .addOption(opts_1.Opts[Opt.IGNORE_SSL])\n    .addOption(opts_1.Opts[Opt.PROXY])\n    .addOption(opts_1.Opts[Opt.ALTERNATE_CDN])\n    .addOption(opts_1.Opts[Opt.STANDALONE])\n    .addOption(opts_1.Opts[Opt.CHROME])\n    .addOption(opts_1.Opts[Opt.GECKO])\n    .addOption(opts_1.Opts[Opt.ANDROID])\n    .addOption(opts_1.Opts[Opt.ANDROID_API_LEVELS])\n    .addOption(opts_1.Opts[Opt.ANDROID_ARCHITECTURES])\n    .addOption(opts_1.Opts[Opt.ANDROID_PLATFORMS])\n    .addOption(opts_1.Opts[Opt.ANDROID_ACCEPT_LICENSES]);\nif (config_1.Config.osType() === 'Darwin') {\n    prog.addOption(opts_1.Opts[Opt.IOS]);\n}\nif (config_1.Config.osType() === 'Windows_NT') {\n    prog.addOption(opts_1.Opts[Opt.IE]).addOption(opts_1.Opts[Opt.IE32]).addOption(opts_1.Opts[Opt.IE64]);\n}\nprog.addOption(opts_1.Opts[Opt.VERSIONS_STANDALONE])\n    .addOption(opts_1.Opts[Opt.VERSIONS_CHROME])\n    .addOption(opts_1.Opts[Opt.VERSIONS_APPIUM])\n    .addOption(opts_1.Opts[Opt.VERSIONS_ANDROID])\n    .addOption(opts_1.Opts[Opt.VERSIONS_GECKO]);\nif (config_1.Config.osType() === 'Windows_NT') {\n    prog.addOption(opts_1.Opts[Opt.VERSIONS_IE]);\n}\nexports.program = prog;\n// stand alone runner\nlet argv = minimist(process.argv.slice(2), prog.getMinimistOptions());\nif (argv._[0] === 'update-run') {\n    prog.run(JSON.parse(JSON.stringify(argv)));\n}\nelse if (argv._[0] === 'update-help') {\n    prog.printHelp();\n}\nlet browserFile;\n/**\n * Parses the options and downloads binaries if they do not exist.\n * @param options\n */\nfunction update(options) {\n    let promises = [];\n    let standalone = options[Opt.STANDALONE].getBoolean();\n    let chrome = options[Opt.CHROME].getBoolean();\n    let gecko = options[Opt.GECKO].getBoolean();\n    let ie32 = false;\n    let ie64 = false;\n    if (options[Opt.IE]) {\n        ie32 = ie32 || options[Opt.IE].getBoolean();\n    }\n    if (options[Opt.IE32]) {\n        ie32 = ie32 || options[Opt.IE32].getBoolean();\n    }\n    if (options[Opt.IE64]) {\n        ie64 = options[Opt.IE64].getBoolean();\n    }\n    let android = options[Opt.ANDROID].getBoolean();\n    let ios = false;\n    if (options[Opt.IOS]) {\n        ios = options[Opt.IOS].getBoolean();\n    }\n    let outputDir = options[Opt.OUT_DIR].getString();\n    try {\n        browserFile =\n            JSON.parse(fs.readFileSync(path.resolve(outputDir, 'update-config.json')).toString());\n    }\n    catch (err) {\n        browserFile = {};\n    }\n    let android_api_levels = options[Opt.ANDROID_API_LEVELS].getString().split(',');\n    let android_architectures = options[Opt.ANDROID_ARCHITECTURES].getString().split(',');\n    let android_platforms = options[Opt.ANDROID_PLATFORMS].getString().split(',');\n    let android_accept_licenses = options[Opt.ANDROID_ACCEPT_LICENSES].getBoolean();\n    if (options[Opt.OUT_DIR].getString()) {\n        if (path.isAbsolute(options[Opt.OUT_DIR].getString())) {\n            outputDir = options[Opt.OUT_DIR].getString();\n        }\n        else {\n            outputDir = path.resolve(config_1.Config.getBaseDir(), options[Opt.OUT_DIR].getString());\n        }\n        files_1.FileManager.makeOutputDirectory(outputDir);\n    }\n    let ignoreSSL = options[Opt.IGNORE_SSL].getBoolean();\n    let proxy = options[Opt.PROXY].getString();\n    let verbose = options[Opt.VERBOSE].getBoolean();\n    // setup versions for binaries\n    let binaries = files_1.FileManager.setupBinaries(options[Opt.ALTERNATE_CDN].getString());\n    binaries[binaries_1.Standalone.id].versionCustom = options[Opt.VERSIONS_STANDALONE].getString();\n    binaries[binaries_1.ChromeDriver.id].versionCustom = options[Opt.VERSIONS_CHROME].getString();\n    if (options[Opt.VERSIONS_IE]) {\n        binaries[binaries_1.IEDriver.id].versionCustom = options[Opt.VERSIONS_IE].getString();\n    }\n    if (options[Opt.VERSIONS_GECKO]) {\n        binaries[binaries_1.GeckoDriver.id].versionCustom = options[Opt.VERSIONS_GECKO].getString();\n    }\n    binaries[binaries_1.AndroidSDK.id].versionCustom = options[Opt.VERSIONS_ANDROID].getString();\n    binaries[binaries_1.Appium.id].versionCustom = options[Opt.VERSIONS_APPIUM].getString();\n    // if the file has not been completely downloaded, download it\n    // else if the file has already been downloaded, unzip the file, rename it, and give it\n    // permissions\n    if (standalone) {\n        let binary = binaries[binaries_1.Standalone.id];\n        promises.push(files_1.FileManager.downloadFile(binary, outputDir, proxy, ignoreSSL)\n            .then((downloaded) => {\n            if (!downloaded) {\n                logger.info(binary.name + ': file exists ' +\n                    path.resolve(outputDir, binary.filename()));\n                logger.info(binary.name + ': ' + binary.filename() + ' up to date');\n            }\n        })\n            .then(() => {\n            updateBrowserFile(binary, outputDir);\n        }));\n    }\n    if (chrome) {\n        let binary = binaries[binaries_1.ChromeDriver.id];\n        promises.push(updateBinary(binary, outputDir, proxy, ignoreSSL).then(() => {\n            return Promise.resolve(updateBrowserFile(binary, outputDir));\n        }));\n    }\n    if (gecko) {\n        let binary = binaries[binaries_1.GeckoDriver.id];\n        promises.push(updateBinary(binary, outputDir, proxy, ignoreSSL).then(() => {\n            return Promise.resolve(updateBrowserFile(binary, outputDir));\n        }));\n    }\n    if (ie64) {\n        let binary = binaries[binaries_1.IEDriver.id];\n        binary.osarch = config_1.Config.osArch(); // Win32 or x64\n        promises.push(updateBinary(binary, outputDir, proxy, ignoreSSL).then(() => {\n            return Promise.resolve(updateBrowserFile(binary, outputDir));\n        }));\n    }\n    if (ie32) {\n        let binary = binaries[binaries_1.IEDriver.id];\n        binary.osarch = 'Win32';\n        promises.push(updateBinary(binary, outputDir, proxy, ignoreSSL).then(() => {\n            return Promise.resolve(updateBrowserFile(binary, outputDir));\n        }));\n    }\n    if (android) {\n        let binary = binaries[binaries_1.AndroidSDK.id];\n        let sdk_path = path.resolve(outputDir, binary.executableFilename());\n        let oldAVDList;\n        updateBrowserFile(binary, outputDir);\n        promises.push(q.nfcall(fs.readFile, path.resolve(sdk_path, 'available_avds.json'))\n            .then((oldAVDs) => {\n            oldAVDList = oldAVDs;\n        }, () => {\n            oldAVDList = '[]';\n        })\n            .then(() => {\n            return updateBinary(binary, outputDir, proxy, ignoreSSL);\n        })\n            .then(() => {\n            initialize_1.android(path.resolve(outputDir, binary.executableFilename()), android_api_levels, android_architectures, android_platforms, android_accept_licenses, binaries[binaries_1.AndroidSDK.id].versionCustom, JSON.parse(oldAVDList), logger, verbose);\n        }));\n    }\n    if (ios) {\n        initialize_1.iOS(logger);\n    }\n    if (android || ios) {\n        installAppium(binaries[binaries_1.Appium.id], outputDir);\n        updateBrowserFile(binaries[binaries_1.Appium.id], outputDir);\n    }\n    return Promise.all(promises).then(() => {\n        writeBrowserFile(outputDir);\n    });\n}\nfunction updateBinary(binary, outputDir, proxy, ignoreSSL) {\n    return files_1.FileManager\n        .downloadFile(binary, outputDir, proxy, ignoreSSL, (binary, outputDir, fileName) => {\n        unzip(binary, outputDir, fileName);\n    })\n        .then(downloaded => {\n        if (!downloaded) {\n            // The file did not have to download, we should unzip it.\n            logger.info(binary.name + ': file exists ' + path.resolve(outputDir, binary.filename()));\n            let fileName = binary.filename();\n            unzip(binary, outputDir, fileName);\n            logger.info(binary.name + ': ' + binary.executableFilename() + ' up to date');\n        }\n    });\n}\nfunction unzip(binary, outputDir, fileName) {\n    // remove the previously saved file and unzip it\n    let osType = config_1.Config.osType();\n    let mv = path.resolve(outputDir, binary.executableFilename());\n    try {\n        fs.unlinkSync(mv);\n    }\n    catch (err) {\n        try {\n            rimraf.sync(mv);\n        }\n        catch (err2) {\n        }\n    }\n    // unzip the file\n    logger.info(binary.name + ': unzipping ' + fileName);\n    if (fileName.slice(-4) == '.zip') {\n        let zip = new AdmZip(path.resolve(outputDir, fileName));\n        zip.extractAllTo(outputDir, true);\n    }\n    else {\n        // We will only ever get .tar files on linux\n        child_process.spawnSync('tar', ['zxvf', path.resolve(outputDir, fileName), '-C', outputDir]);\n    }\n    // rename\n    fs.renameSync(path.resolve(outputDir, binary.zipContentName()), mv);\n    // set permissions\n    if (osType !== 'Windows_NT') {\n        logger.info(binary.name + ': setting permissions to 0755 for ' + mv);\n        if (binary.id() !== binaries_1.AndroidSDK.id) {\n            fs.chmodSync(mv, '0755');\n        }\n        else {\n            fs.chmodSync(path.resolve(mv, 'tools', 'android'), '0755');\n            fs.chmodSync(path.resolve(mv, 'tools', 'emulator'), '0755');\n            // TODO(sjelin): get 64 bit versions working\n        }\n    }\n}\nfunction installAppium(binary, outputDir) {\n    logger.info('appium: installing appium');\n    let folder = path.resolve(outputDir, binary.filename());\n    try {\n        rimraf.sync(folder);\n    }\n    catch (err) {\n    }\n    fs.mkdirSync(folder);\n    fs.writeFileSync(path.resolve(folder, 'package.json'), JSON.stringify({ scripts: { appium: 'appium' } }));\n    utils_1.spawn('npm', ['install', 'appium@' + binary.version()], null, { cwd: folder });\n}\nfunction updateBrowserFile(binary, outputDir) {\n    let currentDownload = path.resolve(outputDir, binary.executableFilename());\n    // if browserFile[id] exists, we should update it\n    if (browserFile[binary.id()]) {\n        let binaryPath = browserFile[binary.id()];\n        if (binaryPath.last === currentDownload) {\n            return;\n        }\n        else {\n            binaryPath.last = currentDownload;\n            for (let bin of binaryPath.all) {\n                if (bin === currentDownload) {\n                    return;\n                }\n            }\n            binaryPath.all.push(currentDownload);\n        }\n    }\n    else {\n        // The browserFile[id] does not exist / has not been downloaded previously.\n        // We should create the entry.\n        let binaryPath = { last: currentDownload, all: [currentDownload] };\n        browserFile[binary.id()] = binaryPath;\n    }\n}\nfunction writeBrowserFile(outputDir) {\n    let filePath = path.resolve(outputDir, 'update-config.json');\n    fs.writeFileSync(filePath, JSON.stringify(browserFile));\n}\n// for testing\nfunction clearBrowserFile() {\n    browserFile = {};\n}\nexports.clearBrowserFile = clearBrowserFile;\n//# sourceMappingURL=update.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/cmds/initialize.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst child_process_1 = require(\"child_process\");\nconst fs = require(\"fs\");\nconst glob = require(\"glob\");\nconst ini = require(\"ini\");\nconst path = require(\"path\");\nconst q = require(\"q\");\nconst config_1 = require(\"../config\");\nconst utils_1 = require(\"../utils\");\nconst noop = () => { };\n// Make a function which configures a child process to automatically respond\n// to a certain question\nfunction respondFactory(question, answer, verbose) {\n    return (child) => {\n        child.stdin.setDefaultEncoding('utf-8');\n        child.stdout.on('data', (data) => {\n            if (data != null) {\n                if (verbose) {\n                    process.stdout.write(data);\n                }\n                if (data.toString().indexOf(question) != -1) {\n                    child.stdin.write(answer + '\\n');\n                }\n            }\n        });\n    };\n}\n// Run a command on the android SDK\nfunction runAndroidSDKCommand(sdkPath, cmd, args, stdio, config_fun) {\n    let child = utils_1.spawn(path.resolve(sdkPath, 'tools', 'android'), [cmd].concat(args), stdio);\n    if (config_fun) {\n        config_fun(child);\n    }\n    ;\n    let deferred = q.defer();\n    child.on('exit', (code) => {\n        if (deferred != null) {\n            if (code) {\n                deferred.reject(code);\n            }\n            else {\n                deferred.resolve();\n            }\n            deferred = null;\n        }\n    });\n    child.on('error', (err) => {\n        if (deferred != null) {\n            deferred.reject(err);\n            deferred = null;\n        }\n    });\n    return deferred.promise;\n}\n// Download updates via the android SDK\nfunction downloadAndroidUpdates(sdkPath, targets, search_all, auto_accept, verbose) {\n    return runAndroidSDKCommand(sdkPath, 'update', ['sdk', '-u'].concat(search_all ? ['-a'] : []).concat(['-t', targets.join(',')]), auto_accept ? 'pipe' : 'inherit', auto_accept ? respondFactory('Do you accept the license', 'y', verbose) : noop);\n}\n// Setup hardware acceleration for x86-64 emulation\nfunction setupHardwareAcceleration(sdkPath) {\n    // TODO(sjelin): linux setup\n    let toolDir = path.resolve(sdkPath, 'extras', 'intel', 'Hardware_Accelerated_Execution_Manager');\n    if (config_1.Config.osType() == 'Darwin') {\n        console.log('Enabling hardware acceleration (requires root access)');\n        // We don't need the wrapped spawnSync because we know we're on OSX\n        child_process_1.spawnSync('sudo', ['silent_install.sh'], { stdio: 'inherit', cwd: toolDir });\n    }\n    else if (config_1.Config.osType() == 'Windows_NT') {\n        console.log('Enabling hardware acceleration (requires admin access)');\n        // We don't need the wrapped spawnSync because we know we're on windows\n        child_process_1.spawnSync('silent_install.bat', [], { stdio: 'inherit', cwd: toolDir });\n    }\n}\n// Get a list of all the SDK download targets for a given set of APIs,\n// architectures, and platforms\nfunction getAndroidSDKTargets(apiLevels, architectures, platforms, oldAVDs) {\n    function getSysImgTarget(architecture, platform, level) {\n        if (platform.toUpperCase() == 'DEFAULT') {\n            platform = 'android';\n        }\n        return 'sys-img-' + architecture + '-' + platform + '-' + level;\n    }\n    let targets = apiLevels\n        .map((level) => {\n        return 'android-' + level;\n    })\n        .concat(architectures.reduce((targets, architecture) => {\n        return targets.concat.apply(targets, platforms.map((platform) => {\n            return apiLevels.map(getSysImgTarget.bind(null, architecture, platform));\n        }));\n    }, []));\n    oldAVDs.forEach((name) => {\n        let avd = new AVDDescriptor(name);\n        if (targets.indexOf(avd.api) == -1) {\n            targets.push(avd.api);\n        }\n        let sysImgTarget = getSysImgTarget(avd.architecture, avd.platform, avd.api.slice('android-'.length));\n        if (targets.indexOf(sysImgTarget) == -1) {\n            targets.push(sysImgTarget);\n        }\n    });\n    return targets;\n}\n// All the information about an android virtual device\nclass AVDDescriptor {\n    constructor(api, platform, architecture) {\n        if (platform != undefined) {\n            this.api = api;\n            this.platform = platform;\n            this.architecture = architecture;\n            this.name = [api, platform, architecture].join('-');\n        }\n        else {\n            this.name = api;\n            let nameParts = this.name.split('-');\n            this.api = nameParts[0] + '-' + nameParts[1];\n            if (/v[0-9]+[a-z]+/.test(nameParts[nameParts.length - 1]) &&\n                (nameParts[nameParts.length - 2].slice(0, 3) == 'arm')) {\n                this.architecture = nameParts[nameParts.length - 2] + '-' + nameParts[nameParts.length - 1];\n            }\n            else {\n                this.architecture = nameParts[nameParts.length - 1];\n            }\n            this.platform = this.name.slice(this.api.length + 1, -this.architecture.length - 1);\n        }\n        this.abi =\n            (this.platform.toUpperCase() == 'DEFAULT' ? '' : this.platform + '/') + this.architecture;\n    }\n    avdName(version) {\n        return this.name + '-v' + version + '-wd-manager';\n    }\n}\n// Gets the descriptors for all AVDs which are possible to make given the\n// SDKs which were downloaded\nfunction getAVDDescriptors(sdkPath) {\n    let deferred = q.defer();\n    // `glob` package always prefers patterns to use `/`\n    glob('system-images/*/*/*', { cwd: sdkPath }, (err, files) => {\n        if (err) {\n            deferred.reject(err);\n        }\n        else {\n            deferred.resolve(files.map((file) => {\n                // `file` could use `/` or `\\`, so we use `path.normalize`\n                let info = path.normalize(file).split(path.sep).slice(-3);\n                return new AVDDescriptor(info[0], info[1], info[2]);\n            }));\n        }\n    });\n    return deferred.promise;\n}\nfunction sequentialForEach(array, func) {\n    let ret = q(null);\n    array.forEach((x) => {\n        ret = ret.then(() => {\n            return func(x);\n        });\n    });\n    return ret;\n}\n// Configures the hardware.ini file for a system image of a new AVD\nfunction configureAVDHardware(sdkPath, desc) {\n    let file = path.resolve(sdkPath, 'system-images', desc.api, desc.platform, desc.architecture, 'hardware.ini');\n    return q.nfcall(fs.stat, file)\n        .then((stats) => {\n        return q.nfcall(fs.readFile, file);\n    }, (err) => {\n        return q('');\n    })\n        .then((contents) => {\n        let config = ini.parse(contents.toString());\n        config['hw.keyboard'] = 'yes';\n        config['hw.battery'] = 'yes';\n        config['hw.ramSize'] = 1024;\n        return q.nfcall(fs.writeFile, file, ini.stringify(config));\n    });\n}\n// Make an android virtual device\nfunction makeAVD(sdkPath, desc, version, verbose) {\n    return runAndroidSDKCommand(sdkPath, 'delete', ['avd', '--name', desc.avdName(version)])\n        .then(noop, noop)\n        .then(() => {\n        return runAndroidSDKCommand(sdkPath, 'create', ['avd', '--name', desc.avdName(version), '--target', desc.api, '--abi', desc.abi], 'pipe', respondFactory('Do you wish to create a custom hardware profile', 'no', verbose));\n    });\n}\n// Initialize the android SDK\nfunction android(sdkPath, apiLevels, architectures, platforms, acceptLicenses, version, oldAVDs, logger, verbose) {\n    let avdDescriptors;\n    let tools = ['platform-tool', 'tool'];\n    if ((config_1.Config.osType() == 'Darwin') || (config_1.Config.osType() == 'Windows_NT')) {\n        tools.push('extra-intel-Hardware_Accelerated_Execution_Manager');\n    }\n    logger.info('android-sdk: Downloading additional SDK updates');\n    downloadAndroidUpdates(sdkPath, tools, false, acceptLicenses, verbose)\n        .then(() => {\n        return setupHardwareAcceleration(sdkPath);\n    })\n        .then(() => {\n        logger.info('android-sdk: Downloading more additional SDK updates ' +\n            '(this may take a while)');\n        return downloadAndroidUpdates(sdkPath, ['build-tools-24.0.0'].concat(getAndroidSDKTargets(apiLevels, architectures, platforms, oldAVDs)), true, acceptLicenses, verbose);\n    })\n        .then(() => {\n        return getAVDDescriptors(sdkPath);\n    })\n        .then((descriptors) => {\n        avdDescriptors = descriptors;\n        logger.info('android-sdk: Configuring virtual device hardware');\n        return sequentialForEach(avdDescriptors, (descriptor) => {\n            return configureAVDHardware(sdkPath, descriptor);\n        });\n    })\n        .then(() => {\n        return sequentialForEach(avdDescriptors, (descriptor) => {\n            logger.info('android-sdk: Setting up virtual device \"' + descriptor.name + '\"');\n            return makeAVD(sdkPath, descriptor, version, verbose);\n        });\n    })\n        .then(() => {\n        return q.nfcall(fs.writeFile, path.resolve(sdkPath, 'available_avds.json'), JSON.stringify(avdDescriptors.map((descriptor) => {\n            return descriptor.name;\n        })));\n    })\n        .then(() => {\n        logger.info('android-sdk: Initialization complete');\n    })\n        .done();\n}\nexports.android = android;\n;\nfunction iOS(logger) {\n    if (config_1.Config.osType() != 'Darwin') {\n        throw new Error('Must be on a Mac to simulate iOS devices.');\n    }\n    try {\n        fs.statSync('/Applications/Xcode.app');\n    }\n    catch (e) {\n        logger.warn('You must install the xcode commandline tools!');\n    }\n}\nexports.iOS = iOS;\n//# sourceMappingURL=initialize.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/built/lib/cmds/version.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst minimist = require(\"minimist\");\nconst cli_1 = require(\"../cli\");\nconst config_1 = require(\"../config\");\nlet logger = new cli_1.Logger('version');\nlet prog = new cli_1.Program().command('version', 'get the current version').action(getVersion);\nexports.program = prog;\n// stand alone runner\nlet argv = minimist(process.argv.slice(2), prog.getMinimistOptions());\nif (argv._[0] === 'version-run') {\n    prog.run(JSON.parse(JSON.stringify(argv)));\n}\nfunction getVersion() {\n    logger.info('webdriver-manager', config_1.Config.getVersion());\n}\n//# sourceMappingURL=version.js.map","/home/travis/build/npmtest/node-npmtest-webdriver-manager/node_modules/webdriver-manager/gulpfile.js":"'use strict';\n\nvar path = require('path');\nvar gulp = require('gulp');\nvar runSequence = require('run-sequence');\nvar spawn = require('child_process').spawn;\n\nvar runSpawn = function(task, args, done) {\n  done = done || function() {};\n  var child = spawn(task, args, {stdio: 'inherit'});\n  var running = false;\n  child.on('close', function(code) {\n    if (!running) {\n      running = true;\n      done(code);\n    }\n  });\n  child.on('error', function(err) {\n    if (!running) {\n      console.error('gulp encountered a child error');\n      running = true;\n      done(err || 1);\n    }\n  });\n  return child;\n};\n\n// Build\ngulp.task('copy', function() {\n  return gulp.src(['config.json', 'package.json'])\n      .pipe(gulp.dest('built/'));\n});\n\nvar tsGlobs = ['lib/**/*.ts', '*spec/**/*.ts'];\n\ngulp.task('format:enforce', () => {\n  const format = require('gulp-clang-format');\n  const clangFormat = require('clang-format');\n  return gulp.src(tsGlobs).pipe(\n    format.checkFormat('file', clangFormat, {verbose: true, fail: true}));\n});\n\ngulp.task('format', () => {\n  const format = require('gulp-clang-format');\n  const clangFormat = require('clang-format');\n  return gulp.src(tsGlobs, { base: '.' }).pipe(\n    format.format('file', clangFormat)).pipe(gulp.dest('.'));\n});\n\ngulp.task('tsc', function(done) {\n  runSpawn(process.execPath, ['node_modules/typescript/bin/tsc'], done);\n});\n\ngulp.task('prepublish', function(done) {\n  runSequence('tsc', 'copy', done);\n});\n\ngulp.task('default', ['prepublish']);\ngulp.task('build', ['prepublish']);\n\n// Unit Test Commands\ngulp.task('test:unit', ['format', 'build'], function(done) {\n  runSpawn(process.execPath, ['node_modules/jasmine/bin/jasmine.js'], done);\n});\n\n// e2e test helper commands\nvar e2e_env = {headless: false, kvm: true};\ngulp.task('update', ['build'], function(done) {\n  runSpawn(process.execPath, ['bin/webdriver-manager', 'update', '--android',\n      '--android-accept-licenses'], done)\n});\ngulp.task('start', ['build', 'shutdown'], function(done) {\n  runSpawn(process.execPath, ['bin/webdriver-manager', 'start', '--detach', '--seleniumPort',\n      '4444', '--android', '--appium-port', '4723', \n      '--quiet'].concat(e2e_env.headless ||\n          !e2e_env.kvm ? ['--avds', 'none'] : []), done);\n});\ngulp.task('shutdown', ['build'], function(done) {\n  runSpawn(process.execPath, ['bin/webdriver-manager', 'shutdown'], done);\n});\n\ngulp.task('test:e2e:inner', ['build'], function(done) {\n  var config = e2e_env.headless ? 'headless.json' : e2e_env.kvm ? 'full.json' : 'no_android.json';\n  runSpawn(process.execPath, ['node_modules/jasmine/bin/jasmine.js', 'JASMINE_CONFIG_PATH=' +\n      path.join('e2e_spec', 'support', config)], done);\n});\ngulp.task('test:e2e:no_update', function(done) {\n  runSequence('start', 'test:e2e:inner', 'shutdown', done);\n});\ngulp.task('test:e2e', function(done) {\n  runSequence('update', 'test:e2e:no_update', done);\n});\n\n\n// Final command\ngulp.task('test', ['test:unit', 'test:e2e']);\ngulp.task('test:no_update', ['test:unit', 'test:e2e:no_update']);\ngulp.task('test:e2e:no_kvm', [], function(done) {\n  e2e_env.kvm = false;\n  runSequence('test:e2e', done);\n});\n"}